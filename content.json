{"meta":{"title":"Jade's","subtitle":"some time some tings","description":"This is My Home. 写些技术的，聊点家常的。","author":"Jade","url":"http://imjade.github.io"},"pages":[{},{},{},{},{},{}],"posts":[{"title":"Android的activity","date":"2017-11-17T04:06:20.000Z","path":"posts/default/2017-11-17-Android的activity.html","text":"Activity 是什么 简述：123Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。(类似UIViewController) 创建：创建Activity必须要在AndroidManifest.xml声明Activity。 1234567&lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=&quot;.ExampleActivity&quot; /&gt; ... &lt;/application ... &gt; ...&lt;/manifest &gt; 设置intent-filter：创建项目时，自动创建 默认启动的MainActivity。 123456&lt;activity android:name=&quot;.MainActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Activity 启动： 无回调：startActivity()。ExampleActivity是要启动的Activity 12Intent intent = new Intent(this, ExampleActivity.class);startActivity(intent); 有回调：startActivityForResult()。需实现回调：onActivityResult 1234567891011121314151617181920ExampleRequestCode = 2;//请求码：用于区分哪个Activity的回调Intent intent = new Intent(this, ExampleActivity.class);startActivityForResult(intent,ExampleRequestCode);@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == ExampleRequestCode &amp;&amp; resultCode == Activity.RESULT_OK) &#123; &#125; &#125;-- ExampleActivity--resultCode = 1;//结果码：用于区分回调方法的状态void finishActivity() &#123; Intent intent = new Intent(); intent.putExtra(&quot;param&quot;, &quot;1&quot;); setResult(resultCode,intent); finish(); &#125; 传值：启动时可以用Intent和bundle传参数。 123456789101112131415161718192021222324-- Intent -- Intent intent = new Intent(this, ExampleActivity.class);intent.putExtra(&quot;age&quot;, 25);intent.putExtra(&quot;address&quot;, &quot;guangzhou&quot;);startActivity(intent);ExampleActivity:Intent intent = getIntent(); int age = intent.getIntExtra(&quot;age&quot;,0); String addressString = intent.getStringExtra(&quot;address&quot;);-- Bundle -- Intent intent = new Intent(this, ExampleActivity.class);Bundle bundle = new Bundle();bundle.putInt(&quot;age&quot;, 25);bundle.putString(&quot;address&quot;, &quot;guangzhou&quot;);intent.putExtras(bundle); startActivity(intent);ExampleActivity:Intent intent = getIntent(); Bundle bundle = intent.getExtras(); int age = bundle.getInt(&quot;age&quot;); String addressString = bundle.getString(&quot;address&quot;); Activity 结束/关闭： 123finish(); //关闭当前页面Activity.finish();//关闭某个ActivitySystem.exit(0); //退出程序 Activity生命周期： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ExampleActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // The activity is being created. //首次创建 Activity 时调用。 您应该在此方法中执行所有正常的静态设置 — 创建视图、将数据绑定到列表等等(ViewDidLoad) &#125; @Override protected void onReStart() &#123; super.onStart(); //在 Activity 已停止并即将再次启动前调用。 &#125; @Override protected void onStart() &#123; super.onStart(); // The activity is about to become visible. //在 Activity 即将对用户可见之前调用。(ViewWillAppear) &#125; @Override protected void onResume() &#123; super.onResume(); // The activity has become visible (it is now &quot;resumed&quot;). //在 Activity 即将开始与用户进行交互之前调用。(ViewDidAppear) &#125; @Override protected void onPause() &#123; super.onPause(); // Another activity is taking focus (this activity is about to be &quot;paused&quot;). //当系统即将开始继续另一个 Activity 时调用。 此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。 (ViewWillDisAppear) &#125; @Override protected void onStop() &#123; super.onStop(); // The activity is no longer visible (it is now &quot;stopped&quot;) //在 Activity 对用户不再可见时调用。(ViewDidDisAppear) &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // The activity is about to be destroyed. //在 Activity 被销毁前调用.(dealloc) &#125;&#125;","content":"<ol>\n<li>Activity 是什么</li>\n</ol>\n<ul>\n<li>简述：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。</span><br><span class=\"line\">每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。</span><br><span class=\"line\">(类似UIViewController)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>创建：创建Activity必须要在AndroidManifest.xml声明Activity。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;manifest ... &gt;</span><br><span class=\"line\">  &lt;application ... &gt;</span><br><span class=\"line\">      &lt;activity android:name=&quot;.ExampleActivity&quot; /&gt;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  &lt;/application ... &gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/manifest &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置intent-filter：创建项目时，自动创建 默认启动的MainActivity。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;.MainActivity&quot; android:icon=&quot;@drawable/app_icon&quot;&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>Activity 启动：</li>\n</ol>\n<ul>\n<li><p>无回调：startActivity()。ExampleActivity是要启动的Activity</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = new Intent(this, ExampleActivity.class);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有回调：startActivityForResult()。需实现回调：onActivityResult</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExampleRequestCode = 2;//请求码：用于区分哪个Activity的回调</span><br><span class=\"line\"></span><br><span class=\"line\">Intent intent = new Intent(this, ExampleActivity.class);</span><br><span class=\"line\">startActivityForResult(intent,ExampleRequestCode);</span><br><span class=\"line\"></span><br><span class=\"line\">@Override  </span><br><span class=\"line\">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;  </span><br><span class=\"line\">    super.onActivityResult(requestCode, resultCode, data);  </span><br><span class=\"line\">    if (requestCode == ExampleRequestCode &amp;&amp; resultCode == Activity.RESULT_OK) &#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ExampleActivity--</span><br><span class=\"line\">resultCode = 1;//结果码：用于区分回调方法的状态</span><br><span class=\"line\">void finishActivity() &#123;  </span><br><span class=\"line\">    Intent intent = new Intent();  </span><br><span class=\"line\">    intent.putExtra(&quot;param&quot;, &quot;1&quot;);  </span><br><span class=\"line\">    setResult(resultCode,intent);  </span><br><span class=\"line\">    finish();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传值：启动时可以用Intent和bundle传参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Intent -- </span><br><span class=\"line\">Intent intent = new Intent(this, ExampleActivity.class);</span><br><span class=\"line\">intent.putExtra(&quot;age&quot;, 25);</span><br><span class=\"line\">intent.putExtra(&quot;address&quot;, &quot;guangzhou&quot;);</span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br><span class=\"line\">ExampleActivity:</span><br><span class=\"line\">Intent intent = getIntent();  </span><br><span class=\"line\">int age = intent.getIntExtra(&quot;age&quot;,0);  </span><br><span class=\"line\">String addressString = intent.getStringExtra(&quot;address&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">-- Bundle -- </span><br><span class=\"line\">Intent intent = new Intent(this, ExampleActivity.class);</span><br><span class=\"line\">Bundle bundle = new Bundle();</span><br><span class=\"line\">bundle.putInt(&quot;age&quot;, 25);</span><br><span class=\"line\">bundle.putString(&quot;address&quot;, &quot;guangzhou&quot;);</span><br><span class=\"line\">intent.putExtras(bundle); </span><br><span class=\"line\">startActivity(intent);</span><br><span class=\"line\"></span><br><span class=\"line\">ExampleActivity:</span><br><span class=\"line\">Intent intent = getIntent(); </span><br><span class=\"line\">Bundle bundle = intent.getExtras(); </span><br><span class=\"line\">int age = bundle.getInt(&quot;age&quot;); </span><br><span class=\"line\">String addressString = bundle.getString(&quot;address&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>Activity 结束/关闭：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finish(); //关闭当前页面</span><br><span class=\"line\">Activity.finish();//关闭某个Activity</span><br><span class=\"line\">System.exit(0); //退出程序</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Activity生命周期：</p>\n</li>\n</ol>\n<p><img src=\"http://developments.qiniudn.com/activity_lifecycle.png\" alt=\"Activity生命周期\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ExampleActivity extends Activity &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        // The activity is being created.</span><br><span class=\"line\">        //首次创建 Activity 时调用。 您应该在此方法中执行所有正常的静态设置 — 创建视图、将数据绑定到列表等等(ViewDidLoad)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onReStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        //在 Activity 已停止并即将再次启动前调用。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        // The activity is about to become visible.</span><br><span class=\"line\">        //在 Activity 即将对用户可见之前调用。(ViewWillAppear)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResume() &#123;</span><br><span class=\"line\">        super.onResume();</span><br><span class=\"line\">        // The activity has become visible (it is now &quot;resumed&quot;).</span><br><span class=\"line\">        //在 Activity 即将开始与用户进行交互之前调用。(ViewDidAppear)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onPause() &#123;</span><br><span class=\"line\">        super.onPause();</span><br><span class=\"line\">        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).</span><br><span class=\"line\">        //当系统即将开始继续另一个 Activity 时调用。</span><br><span class=\"line\">        此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。</span><br><span class=\"line\">        (ViewWillDisAppear)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStop() &#123;</span><br><span class=\"line\">        super.onStop();</span><br><span class=\"line\">        // The activity is no longer visible (it is now &quot;stopped&quot;)</span><br><span class=\"line\">        //在 Activity 对用户不再可见时调用。(ViewDidDisAppear)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDestroy() &#123;</span><br><span class=\"line\">        super.onDestroy();</span><br><span class=\"line\">        // The activity is about to be destroyed.</span><br><span class=\"line\">        //在 Activity 被销毁前调用.(dealloc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","slug":"Android的activity","updated":"2017-11-19T15:01:45.500Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2017-11-17-Android的activity.html","excerpt":"Activity 是什么 简述：123Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。(类似UIViewController)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://imjade.github.io/tags/Android/"}]},{"title":"Jenkins 搭建（Mac 环境）","date":"2016-12-06T11:38:34.000Z","path":"posts/default/2016-12-06-Jenkins-搭建（Mac-环境）.html","text":"1.安装Jenkins 两种方式 http://jenkins-ci.org/ 下载pgk文件直接点击安装(不推荐)。（安装目录：/Users/Shared/Jenkins/下，因为Xcode默认安装在/Users/登录用户/，会有很多操作权限的问题） 用Homebrew安装 （推荐）。首先要安装Homebrew（http://brew.sh/）==修默认安装到/Users/登录用户/ 所以要修改默认安装路径如：/Users/登录用户/jenkins/== 12345sudo vim /etc/profilesudo chmod 775 /etc/profile //修改其文件权限export JENKINS_HOME=(要修改的路径信息)source /etc/profile执行完成重启系统，再打开jenkins就能看到其主目录已修改成功 1.安装Jenkins 1brew install jenkins 2. 启动Jenkins 1jenkins 启动完成之后，可以打开localhost:8080 进行初始化安装。 3.选择安装插件： 123456kpp-management-plugin //证书管理插件GIT plugin //Git插件GitHub plugin //Github插件Post-Build Script Plug-in //脚本执行插件Xcode integration //xcode插件Email Extension Plugin //邮件插件 4.新建JOB，配置。 新建item -&gt; 填写item名称 -&gt; 选择构建类型 -&gt; ok 配置Job。 1.源码管理 -&gt; 选中Git -&gt; 填写Git地址 -&gt; 填写构建Git分支 2.构建触发器 -&gt; 选中Build when a change is pushed to GitHub -&gt; Poll SCM（每晚9点检查Github有代码更新build）。 3.增加构建步骤 -&gt; 选择Xcode -&gt; General build settings 4.增加构建步骤 -&gt; 选择Xcode -&gt; Advanced Xcode build options （Workspace项目）。 5.增加构建后操作步骤 -&gt; Execute a set of scripts -&gt; Add Build Step （打包成功后执行脚本文件，上传文件到蒲公英，并邮件通知） https://github.com/caiwenshu/CI_pgy/blob/master/pgy_upload_temp.py 5.立即构建。 通过点击刚创建的项目 -&gt; 立即构建 （构建成功后会受到邮件通知）。 注： 如果我们需要在非本机以外的电脑上访问 Jenkins，那么需要改一下配置文件（/usr/local/opt/jenkins-lts/homebrew.mxcl.jenkins.plist）在，修改httpListenAddress 后的 ip 地址127.0.0.1修改为本机ip。 相关链接：http://www.jianshu.com/p/371595ef08fehttps://imciel.com/2016/08/27/install-jenkins-tips/http://www.jianshu.com/p/371595ef08fe","content":"<p><strong>1.安装Jenkins 两种方式</strong></p>\n<ul>\n<li><a href=\"http://jenkins-ci.org/\" target=\"_blank\" rel=\"noopener\">http://jenkins-ci.org/</a>  下载pgk文件直接点击安装(不推荐)。（安装目录：/Users/Shared/Jenkins/下，因为Xcode默认安装在/Users/登录用户/，会有很多操作权限的问题）</li>\n<li>用Homebrew安装 （推荐）。首先要安装Homebrew（<a href=\"http://brew.sh/）\" target=\"_blank\" rel=\"noopener\">http://brew.sh/）</a><br>==修默认安装到/Users/登录用户/ 所以要修改默认安装路径如：/Users/登录用户/jenkins/==</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/profile</span><br><span class=\"line\">sudo chmod 775 /etc/profile  //修改其文件权限</span><br><span class=\"line\">export JENKINS_HOME=(要修改的路径信息)</span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">执行完成重启系统，再打开jenkins就能看到其主目录已修改成功</span><br></pre></td></tr></table></figure>\n<p><em>1.安装Jenkins</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><em>2. 启动Jenkins</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jenkins</span><br></pre></td></tr></table></figure>\n<p><code>启动完成之后，可以打开localhost:8080 进行初始化安装。</code></p>\n<p><em>3.选择安装插件：</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kpp-management-plugin //证书管理插件</span><br><span class=\"line\">GIT plugin //Git插件</span><br><span class=\"line\">GitHub plugin //Github插件</span><br><span class=\"line\">Post-Build Script Plug-in //脚本执行插件</span><br><span class=\"line\">Xcode integration //xcode插件</span><br><span class=\"line\">Email Extension Plugin //邮件插件</span><br></pre></td></tr></table></figure>\n<p><em>4.新建JOB，配置。</em></p>\n<ul>\n<li>新建item -&gt;  填写item名称 -&gt; 选择构建类型  -&gt; ok</li>\n</ul>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/15563282.png\" alt=\"图1\"></p>\n<ul>\n<li><p>配置Job。</p>\n<p><code>1.源码管理 -&gt; 选中Git -&gt; 填写Git地址 -&gt; 填写构建Git分支</code></p>\n</li>\n</ul>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/9781674.png\" alt=\"图2\"></p>\n<p><code>2.构建触发器 -&gt; 选中Build when a change is pushed to GitHub -&gt; Poll SCM（每晚9点检查Github有代码更新build）。</code></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/3462242.png\" alt=\"图3\"></p>\n<p><code>3.增加构建步骤 -&gt; 选择Xcode -&gt; General build settings</code></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/untitled.png\" alt=\"图4\"></p>\n<p><code>4.增加构建步骤 -&gt; 选择Xcode -&gt; Advanced Xcode build options （Workspace项目）。</code></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/untitled2.png\" alt=\"图5\"></p>\n<p><code>5.增加构建后操作步骤 -&gt; Execute a set of scripts -&gt; Add Build Step   （打包成功后执行脚本文件，上传文件到蒲公英，并邮件通知）</code></p>\n<p><a href=\"https://github.com/caiwenshu/CI_pgy/blob/master/pgy_upload_temp.py\" target=\"_blank\" rel=\"noopener\">https://github.com/caiwenshu/CI_pgy/blob/master/pgy_upload_temp.py</a></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/untitled3.png\" alt=\"图6\"></p>\n<p><em>5.立即构建。</em></p>\n<p>   通过点击刚创建的项目 -&gt; 立即构建 （构建成功后会受到邮件通知）。</p>\n<p><code>注： 如果我们需要在非本机以外的电脑上访问 Jenkins，那么需要改一下配置文件（/usr/local/opt/jenkins-lts/homebrew.mxcl.jenkins.plist）在，修改httpListenAddress 后的 ip 地址127.0.0.1修改为本机ip。</code></p>\n<p>相关链接：<br><a href=\"http://www.jianshu.com/p/371595ef08fe\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/371595ef08fe</a><br><a href=\"https://imciel.com/2016/08/27/install-jenkins-tips/\" target=\"_blank\" rel=\"noopener\">https://imciel.com/2016/08/27/install-jenkins-tips/</a><br><a href=\"http://www.jianshu.com/p/371595ef08fe\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/371595ef08fe</a></p>\n","slug":"Jenkins-搭建（Mac-环境）","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-Jenkins-搭建（Mac-环境）.html","excerpt":"1.安装Jenkins 两种方式 http://jenkins-ci.org/ 下载pgk文件直接点击安装(不推荐)。（安装目录：/Users/Shared/Jenkins/下，因为Xcode默认安装在/Users/登录用户/，会有很多操作权限的问题） 用Homebrew安装 （推荐）。首先要安装Homebrew（http://brew.sh/）==修默认安装到/Users/登录用户/ 所以要修改默认安装路径如：/Users/登录用户/jenkins/== 12345sudo vim /etc/profilesudo chmod 775 /etc/profile //修改其文件权限export JENKINS_HOME=(要修改的路径信息)source /etc/profile执行完成重启系统，再打开jenkins就能看到其主目录已修改成功 1.安装Jenkins 1brew install jenkins","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://imjade.github.io/tags/Jenkins/"}]},{"title":"Apple Pay的开发设置","date":"2016-12-06T10:14:47.000Z","path":"posts/default/2016-12-06-Apple-Pay的开发设置.html","text":"1.Identifiers-&gt;Merchant ID 新建Merchant ID2. Identifiers-&gt;App IDs新建证书 (不能是*)，Edit-&gt;Apple Pay证书添加Merchant ID 一步一步走就行了。Merchant ID就设置好了。 3.Xcode 设置开启Apple Pay 选择设置的Merchant ID","content":"<p><strong>1.Identifiers-&gt;Merchant ID 新建Merchant ID</strong><br><img src=\"http://o7rvtx931.bkt.clouddn.com/30428d0a-bca0-4f90-9b2e-d1475a461a7a.png\" alt=\"图1\"><br><a id=\"more\"></a><br><strong>2. Identifiers-&gt;App IDs新建证书 (不能是*)，Edit-&gt;Apple Pay证书添加Merchant ID 一步一步走就行了。Merchant ID就设置好了。</strong></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/3008453.png\" alt=\"\"></p>\n<p><strong>3.Xcode 设置开启Apple Pay 选择设置的Merchant ID</strong></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/5630345.png\" alt=\"\"></p>\n","slug":"Apple-Pay的开发设置","updated":"2017-11-17T02:23:17.231Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-Apple-Pay的开发设置.html","excerpt":"1.Identifiers-&gt;Merchant ID 新建Merchant ID","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"根据内存地址定位错误","date":"2016-12-06T10:03:05.000Z","path":"posts/default/2016-12-06-根据内存地址定位错误.html","text":"1.设置开启memory history： 2.开启成功显示 然后有报错就可以1memory history xxxx(报错内存地址)。来输出地址栈来定位错误。","content":"<p><strong>1.设置开启memory history：</strong></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/14806967.png\" alt=\"开启设置\"><br><a id=\"more\"></a><br><strong>2.开启成功显示</strong><br><img src=\"http://o7rvtx931.bkt.clouddn.com/8991745.png\" alt=\"开启成功\"></p>\n<p><strong>然后有报错就可以</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">memory history xxxx(报错内存地址)。来输出地址栈来定位错误。</span><br></pre></td></tr></table></figure></p>\n","slug":"根据内存地址定位错误","updated":"2017-11-17T02:23:17.235Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-根据内存地址定位错误.html","excerpt":"1.设置开启memory history：","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"view切圆角","date":"2016-12-06T09:58:31.000Z","path":"posts/default/2016-12-06-view切圆角.html","text":"123view.layer.cornerRadius = 5;//对view切圆角的角度view.layer.masksToBounds = YES;//这个等于YES。view里边的子view也会切相当于clipsToBouns = YES。//view.layer.masksToBounds = NO;//只切view的圆角不会切view里边view圆角","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.cornerRadius = 5;//对view切圆角的角度</span><br><span class=\"line\">view.layer.masksToBounds = YES;//这个等于YES。view里边的子view也会切相当于clipsToBouns = YES。</span><br><span class=\"line\">//view.layer.masksToBounds = NO;//只切view的圆角不会切view里边view圆角</span><br></pre></td></tr></table></figure>","slug":"view切圆角","updated":"2017-11-17T02:23:17.234Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-view切圆角.html","excerpt":"","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"时间戳（毫秒）转date","date":"2016-12-06T09:51:05.000Z","path":"posts/default/2016-12-06-时间戳（毫秒）转date.html","text":"1.获取毫秒时间戳 UInt64 recordTime = [[NSDate date] timeIntervalSince1970]*1000; [[NSDate date] timeIntervalSince1970] 是可以获取到后面的毫秒 微秒的 ，只是在保存的时候省略掉了， 如一个时间戳不省略的情况下为 1395399556.862046 ，省略掉后为一般所见 1395399556 。所以想取得毫秒时用获取到的时间戳 *1000 ，想取得微秒时 用取到的时间戳 * 1000 * 1000 2.毫秒时间戳转NSDate NSString * timeStampString = @&quot;1423189125873&quot;; NSTimeInterval _interval=[timeStampString doubleValue] / 1000.0; NSDate *date = [NSDate dateWithTimeIntervalSince1970:_interval]; NSDateFormatter *objDateformat = [[NSDateFormatter alloc] init]; [objDateformat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;]; NSLog(@&quot;%@&quot;, [objDateformat stringFromDate: date]);","content":"<p><strong>1.获取毫秒时间戳</strong></p>\n<pre><code>UInt64 recordTime = [[NSDate date] timeIntervalSince1970]*1000;\n</code></pre><p><code>[[NSDate date] timeIntervalSince1970] 是可以获取到后面的毫秒 微秒的 ，只是在保存的时候省略掉了， 如一个时间戳不省略的情况下为 1395399556.862046 ，省略掉后为一般所见 1395399556 。所以想取得毫秒时用获取到的时间戳 *1000 ，想取得微秒时 用取到的时间戳 * 1000 * 1000</code></p>\n<p><strong>2.毫秒时间戳转NSDate</strong></p>\n<pre><code>NSString * timeStampString = @&quot;1423189125873&quot;;\nNSTimeInterval _interval=[timeStampString doubleValue] / 1000.0;\nNSDate *date = [NSDate dateWithTimeIntervalSince1970:_interval];\nNSDateFormatter *objDateformat = [[NSDateFormatter alloc] init];\n[objDateformat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;];\nNSLog(@&quot;%@&quot;, [objDateformat stringFromDate: date]);\n</code></pre>","slug":"时间戳（毫秒）转date","updated":"2017-11-17T02:23:17.234Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-时间戳（毫秒）转date.html","excerpt":"","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"NSDataDetector","date":"2016-12-06T09:36:51.000Z","path":"posts/default/2016-12-06-NSDataDetector.html","text":"1.NSDataDetector是继承于NSRegularExpression（Cocoa中的正则表达式）的一个子类。系统帮做好的一些正则匹配。 public static var orthography: NSTextCheckingResult.CheckingType { get } // language identification public static var spelling: NSTextCheckingResult.CheckingType { get } // spell checking public static var grammar: NSTextCheckingResult.CheckingType { get } // grammar checking public static var date: NSTextCheckingResult.CheckingType { get } // date/time detection public static var address: NSTextCheckingResult.CheckingType { get } // address detection public static var link: NSTextCheckingResult.CheckingType { get } // link detection public static var quote: NSTextCheckingResult.CheckingType { get } // smart quotes public static var dash: NSTextCheckingResult.CheckingType { get } // smart dashes public static var replacement: NSTextCheckingResult.CheckingType { get } // fixed replacements, such as copyright symbol for (c) public static var correction: NSTextCheckingResult.CheckingType { get } // autocorrection @available(iOS 4.0, *) public static var regularExpression: NSTextCheckingResult.CheckingType { get } // regular expression matches @available(iOS 4.0, *) public static var phoneNumber: NSTextCheckingResult.CheckingType { get } // phone number detection @available(iOS 4.0, *) public static var transitInformation: NSTextCheckingResult.CheckingType { get } // transit (e.g. flight) info detection 2.初始化方法： public init(types checkingTypes: NSTextCheckingTypes) throws 3.几个调用的方法： open func matches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; [NSTextCheckingResult] //返回匹配到的数组 open func numberOfMatches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; Int //返回匹配到的个数 open func firstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; NSTextCheckingResult? //返回第一个匹配到的结果 open func rangeOfFirstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; NSRange //返回第一个匹配到结果的范围 4.使用： lazy var showlabel:UILabel = { let string = &quot;电话号码是15812345678还是15012345678\\n网址是www.baidu.com&quot; let showLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 300, height: 100)) showLabel.center = self.view.center showLabel.font = UIFont.systemFont(ofSize: 14) showLabel.text = string; showLabel.numberOfLines = 0 return showLabel }() override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. setUp() } func setUp() { self.view.addSubview(self.showlabel) let string = self.showlabel.text! as String let types: NSTextCheckingResult.CheckingType = [.phoneNumber,.link] let detector:NSDataDetector = try!NSDataDetector(types: types.rawValue) let attributeText = NSMutableAttributedString(string: string); detector.enumerateMatches(in: string, options: NSRegularExpression.MatchingOptions(rawValue:0), range: NSMakeRange(0, (string as NSString).length), using: { (_result:NSTextCheckingResult?, _flags:NSRegularExpression.MatchingFlags, _:UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void in let range:NSRange = (_result?.range)! print(_result ?? &quot;&quot;); if _result?.resultType == .link { attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.red, range: range) attributeText.addAttribute(NSUnderlineStyleAttributeName, value: NSNumber(value: 1), range: range) }else if _result?.resultType == .phoneNumber { attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.orange, range: range) } self.showlabel.attributedText = attributeText } ) /* * 返回数组匹配到的数组 */ let matches = detector.matches(in: string, options: NSRegularExpression.MatchingOptions(rawValue:0), range: NSMakeRange(0, (string as NSString).length)); for result:NSTextCheckingResult in matches { let range:NSRange = result.range if result.resultType == .link { attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.red, range: range) attributeText.addAttribute(NSUnderlineStyleAttributeName, value: NSNumber(value: 1), range: range) }else if result.resultType == .phoneNumber { attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.orange, range: range) } self.showlabel.attributedText = attributeText } 5.实现效果：","content":"<p>1.NSDataDetector是继承于NSRegularExpression（Cocoa中的正则表达式）的一个子类。系统帮做好的一些正则匹配。</p>\n<pre><code>public static var orthography: NSTextCheckingResult.CheckingType { get } // language identification\npublic static var spelling: NSTextCheckingResult.CheckingType { get } // spell checking\npublic static var grammar: NSTextCheckingResult.CheckingType { get } // grammar checking\npublic static var date: NSTextCheckingResult.CheckingType { get } // date/time detection\npublic static var address: NSTextCheckingResult.CheckingType { get } // address detection\npublic static var link: NSTextCheckingResult.CheckingType { get } // link detection\npublic static var quote: NSTextCheckingResult.CheckingType { get } // smart quotes\npublic static var dash: NSTextCheckingResult.CheckingType { get } // smart dashes\npublic static var replacement: NSTextCheckingResult.CheckingType { get } // fixed replacements, such as copyright symbol for (c)\npublic static var correction: NSTextCheckingResult.CheckingType { get } // autocorrection\n@available(iOS 4.0, *)\npublic static var regularExpression: NSTextCheckingResult.CheckingType { get } // regular expression matches\n@available(iOS 4.0, *)\npublic static var phoneNumber: NSTextCheckingResult.CheckingType { get } // phone number detection\n@available(iOS 4.0, *)\npublic static var transitInformation: NSTextCheckingResult.CheckingType { get } // transit (e.g. flight) info detection\n</code></pre><a id=\"more\"></a>\n<p>2.初始化方法：</p>\n<pre><code>public init(types checkingTypes: NSTextCheckingTypes) throws\n</code></pre><p>3.几个调用的方法：</p>\n<pre><code>open func matches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; [NSTextCheckingResult] //返回匹配到的数组\n    open func numberOfMatches(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; Int   //返回匹配到的个数\n    open func firstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; NSTextCheckingResult? //返回第一个匹配到的结果\n    open func rangeOfFirstMatch(in string: String, options: NSRegularExpression.MatchingOptions = [], range: NSRange) -&gt; NSRange //返回第一个匹配到结果的范围\n</code></pre><p>4.使用：</p>\n<pre><code>lazy var showlabel:UILabel = {\n        let string = &quot;电话号码是15812345678还是15012345678\\n网址是www.baidu.com&quot;\n        let showLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 300, height: 100))\n        showLabel.center = self.view.center\n        showLabel.font = UIFont.systemFont(ofSize: 14)\n        showLabel.text = string;\n        showLabel.numberOfLines = 0\n        return showLabel\n    }()\n\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        setUp()\n    }\n\n    func setUp() {\n        self.view.addSubview(self.showlabel)\n        let string = self.showlabel.text! as String\n\n        let types: NSTextCheckingResult.CheckingType = [.phoneNumber,.link]\n        let detector:NSDataDetector = try!NSDataDetector(types: types.rawValue)\n        let attributeText = NSMutableAttributedString(string: string);\n\n        detector.enumerateMatches(in: string, options: NSRegularExpression.MatchingOptions(rawValue:0), range: NSMakeRange(0, (string as NSString).length), using: {\n            (_result:NSTextCheckingResult?, _flags:NSRegularExpression.MatchingFlags, _:UnsafeMutablePointer&lt;ObjCBool&gt;) -&gt; Void in\n            let range:NSRange = (_result?.range)!\n            print(_result ?? &quot;&quot;);\n\n            if _result?.resultType == .link {\n                attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.red, range: range)\n                attributeText.addAttribute(NSUnderlineStyleAttributeName, value: NSNumber(value: 1), range: range)\n            }else if _result?.resultType == .phoneNumber {\n                attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.orange, range: range)\n            }\n            self.showlabel.attributedText = attributeText\n            }\n        )\n        /*\n         * 返回数组匹配到的数组\n         */\n        let matches = detector.matches(in: string, options: NSRegularExpression.MatchingOptions(rawValue:0), range: NSMakeRange(0, (string as NSString).length));\n        for result:NSTextCheckingResult in matches {\n            let range:NSRange = result.range\n            if result.resultType == .link {\n                attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.red, range: range)\n                attributeText.addAttribute(NSUnderlineStyleAttributeName, value: NSNumber(value: 1), range: range)\n            }else if result.resultType == .phoneNumber {\n                attributeText.addAttribute(NSForegroundColorAttributeName, value: UIColor.orange, range: range)\n            }\n            self.showlabel.attributedText = attributeText\n        }\n</code></pre><p>5.实现效果：<br><img src=\"http://o7rvtx931.bkt.clouddn.com/13748126.png\" alt=\"效果\"></p>\n","slug":"NSDataDetector","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-NSDataDetector.html","excerpt":"1.NSDataDetector是继承于NSRegularExpression（Cocoa中的正则表达式）的一个子类。系统帮做好的一些正则匹配。 public static var orthography: NSTextCheckingResult.CheckingType { get } // language identification public static var spelling: NSTextCheckingResult.CheckingType { get } // spell checking public static var grammar: NSTextCheckingResult.CheckingType { get } // grammar checking public static var date: NSTextCheckingResult.CheckingType { get } // date/time detection public static var address: NSTextCheckingResult.CheckingType { get } // address detection public static var link: NSTextCheckingResult.CheckingType { get } // link detection public static var quote: NSTextCheckingResult.CheckingType { get } // smart quotes public static var dash: NSTextCheckingResult.CheckingType { get } // smart dashes public static var replacement: NSTextCheckingResult.CheckingType { get } // fixed replacements, such as copyright symbol for (c) public static var correction: NSTextCheckingResult.CheckingType { get } // autocorrection @available(iOS 4.0, *) public static var regularExpression: NSTextCheckingResult.CheckingType { get } // regular expression matches @available(iOS 4.0, *) public static var phoneNumber: NSTextCheckingResult.CheckingType { get } // phone number detection @available(iOS 4.0, *) public static var transitInformation: NSTextCheckingResult.CheckingType { get } // transit (e.g. flight) info detection","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"iOS10 国行设备访问网络权限问题","date":"2016-12-06T08:36:14.000Z","path":"posts/default/2016-12-06-iOS10国行设备访问网络权限问题.html","text":"在 iOS 10 中苹果专为国行 iPhone 制定了一个「联网权限」功能 检测网络变化，点击允许之前是没有网络，点击允许后会有网络变化，所以判断不是无网络和不是第一次请求。 [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { if (status != AFNetworkReachabilityStatusNotReachable &amp;&amp; !inited) { [self initRequest]; } }];","content":"<p><a href=\"http://sspai.com/35720\" target=\"_blank\" rel=\"noopener\">在 iOS 10 中苹果专为国行 iPhone 制定了一个「联网权限」功能</a></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/image2.jpg\" alt=\"image\"></p>\n<p>检测网络变化，点击允许之前是没有网络，点击允许后会有网络变化，所以判断不是无网络和不是第一次请求。</p>\n<a id=\"more\"></a>\n<pre><code>[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {\n        if (status != AFNetworkReachabilityStatusNotReachable &amp;&amp; !inited) {\n            [self initRequest];\n        }\n    }];\n</code></pre>","slug":"iOS10国行设备访问网络权限问题","updated":"2017-11-17T02:23:17.233Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-12-06-iOS10国行设备访问网络权限问题.html","excerpt":"在 iOS 10 中苹果专为国行 iPhone 制定了一个「联网权限」功能 检测网络变化，点击允许之前是没有网络，点击允许后会有网络变化，所以判断不是无网络和不是第一次请求。","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"NSTimer、CADisplayLink、GCD 三种定时器的用法","date":"2016-07-15T02:27:51.000Z","path":"posts/default/2016-07-15-NSTimer、CADisplayLink、GCD-三种定时器的用法.html","text":"在软件开发过程中，我们常常需要在某个时间后执行某个方法，或者是按照某个周期一直执行某个方法。在这个时候，我们就需要用到定时器。 在iOS中有很多方法完成定时器的任务，例如 NSTimer、CADisplayLink 和 GCD都可以。一、NSTimer 创建方法 NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:NO]; TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法 target : 需要执行方法的对象。 selector : 需要执行的方法 repeats : 是否需要循环 释放方法 [timer invalidate]; 注意 : 调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。 特点 存在延迟：不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。必须加入Runloop：使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop: NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; 二、CADisplayLink 创建方法 displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; 停止方法 [displayLink invalidate]; displayLink = nil; 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。 特点：屏幕刷新时调用:CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒延迟：iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。 如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。使用场景：从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。 重要属性 frameInterval NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。 duration readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。 三、GCD1.执行一次 double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ //执行事件 }); 2.重复执行 NSTimeInterval period = 1.0; //设置时间间隔 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ //在这里执行事件 }); dispatch_resume(_timer); 相关链接： http://www.mamicode.com/info-detail-647593.html","content":"<p>在软件开发过程中，我们常常需要在某个时间后执行某个方法，或者是按照某个周期一直执行某个方法。在这个时候，我们就需要用到定时器。</p>\n<p>在iOS中有很多方法完成定时器的任务，例如 NSTimer、CADisplayLink 和 GCD都可以。<br><a id=\"more\"></a><br>一、NSTimer</p>\n<ol>\n<li><p>创建方法</p>\n<pre><code>NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:NO];\nTimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法\ntarget : 需要执行方法的对象。\nselector : 需要执行的方法\nrepeats : 是否需要循环\n</code></pre></li>\n<li><p>释放方法</p>\n<pre><code>[timer invalidate];\n</code></pre><p><a>注意 : 调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。</a></p>\n</li>\n<li><p>特点</p>\n<p>存在延迟：不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。<br>必须加入Runloop：使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop:</p>\n<pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n</code></pre></li>\n</ol>\n<p>二、CADisplayLink</p>\n<ol>\n<li><p>创建方法</p>\n<pre><code>displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];\n[displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n</code></pre></li>\n<li><p>停止方法</p>\n<pre><code>[displayLink invalidate];\n displayLink = nil;\n</code></pre><p>当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>\n</li>\n<li>特点：<br><a>屏幕刷新时调用:</a>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒<br><a>延迟：</a>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。 如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。<br><a>使用场景：</a>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</li>\n<li><p>重要属性</p>\n<pre><code>frameInterval\nNSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。\nduration\nreadOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。\n</code></pre><p>三、GCD<br>1.执行一次</p>\n<pre><code>double delayInSeconds = 2.0;\n  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);\n\n   dispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n\n  //执行事件\n\n  });\n</code></pre><p>2.重复执行</p>\n<pre><code>NSTimeInterval period = 1.0; //设置时间间隔\n\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\ndispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行\ndispatch_source_set_event_handler(_timer, ^{\n//在这里执行事件\n});\n\ndispatch_resume(_timer);\n</code></pre></li>\n</ol>\n<p>相关链接：<br>    <a href=\"http://www.mamicode.com/info-detail-647593.html\" target=\"_blank\" rel=\"noopener\">http://www.mamicode.com/info-detail-647593.html</a></p>\n","slug":"NSTimer、CADisplayLink、GCD-三种定时器的用法","updated":"2017-11-17T02:23:17.233Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-07-15-NSTimer、CADisplayLink、GCD-三种定时器的用法.html","excerpt":"在软件开发过程中，我们常常需要在某个时间后执行某个方法，或者是按照某个周期一直执行某个方法。在这个时候，我们就需要用到定时器。 在iOS中有很多方法完成定时器的任务，例如 NSTimer、CADisplayLink 和 GCD都可以。","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"const static extern","date":"2016-07-14T06:25:04.000Z","path":"posts/default/2016-07-14-const-static-extern.html","text":"const static extern 1.const 定义全局常量 和static一样初始化后不能修改，全局范围 2.static 静态变量 ，.h中定义后，在a.m 中赋值后在b.m 中是没有赋值的 。范围只属于本类 3.extern 意思就是这个变量已经定义了，用就可以了。 相关链接:http://blog.csdn.net/xpwang168/article/details/8087143","content":"<p><a>const static extern</a></p>\n<pre><code>1.const 定义全局常量 和static一样初始化后不能修改，全局范围\n2.static 静态变量 ，.h中定义后，在a.m 中赋值后在b.m 中是没有赋值的 。范围只属于本类\n3.extern 意思就是这个变量已经定义了，用就可以了。\n</code></pre><p>相关链接:<br><a href=\"http://blog.csdn.net/xpwang168/article/details/8087143\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xpwang168/article/details/8087143</a></p>\n","slug":"const-static-extern","updated":"2017-11-17T02:23:17.233Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-07-14-const-static-extern.html","excerpt":"","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"IPA Automatic Resign","date":"2016-07-14T06:20:11.000Z","path":"posts/default/2016-07-14-IPA-Resign.html","text":"一个自动重签ipa的需求。 1.https://github.com/maciekish/iReSign 一开始找到了这个自动重签开源工具。可以实现半自动的重签功能。但是并不能满足需求。继续吧 2.找啊找啊，找。。发现所有的工具的源码都是归到了这几步命令。 Step1 : unzip YourApp.ipa Step2: rm -rf Payload/YourApp.app/_CodeSignature Step3: cp InHouse.mobileprovision Payload/YourApp.app/embedded.mobileprovision Step4: /usr/bin/codesign -f -s &quot;iPhone Distribution: YourCompanyName&quot; --resource-rules Payload/YourApp.app/ResourceRules.plist Payload/YourApp.app Step 5: zip -r YourApp_inhouse.ipa Payload * InHouse.mobileprovision 是你要用来签名的provision文件 * iPhone Distribution: YourCompanyName 是指该签名对应的证书的名字。这个可以在keychain中找到 但是会遇ResourceRules.plist找不到的问题，要设置 Click on your project &gt; Targets &gt; Select your target &gt; Build Settings &gt; Code Signing Resource Rules Path and add : $(SDKROOT)/ResourceRules.plist 但是ipa中包含Framework and Plugins 也不能重签成功。3.https://github.com/ikalnitsky/iresign 一个Python 重签脚本 一样的不能重签包含Framework and Plugins 的ipa 4.就在放弃要打算重新看回iReSign源码做外部调用iReSign程序来坐自动重签时，又Google到一个脚本 http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/ 在signall.sh里边修改 signscript=&quot;/path/to/sign.sh&quot; #signscript脚本路径 ipasourcefolder=&quot;path/to/ipas/source/folder&quot; #ipa文件的路径 ipadestfolder=&quot;/path/to/ipas/destinations/folder/&quot; #生成重签ipa路径 developer1=&quot;iPhone Developer: xxxxx (xxxxx)&quot; #是指该签名对应的证书的名字。这个可以在keychain中找到 mobileprovision1=&quot;/path/to/mobile/provision&quot; #要重签的xx.mobileprovision文件路径 cd $ipasourcefolder find -d . -type f -name &quot;*.ipa&quot;&gt; files.txt while IFS=&apos;&apos; read -r line || [[ -n &quot;$line&quot; ]]; do filename=$(basename &quot;$line&quot; .ipa) echo &quot;Ipa: $filename&quot; #_dev1_______ output=$ipadestfolder$filename output+=&quot;_signed_dev1.ipa&quot; #生成重签ipa的后缀名称 &quot;$signscript&quot; &quot;$line&quot; &quot;$developer1&quot; &quot;$mobileprovision1&quot; &quot;$output&quot; done &lt; files.txt rm files.txt 源码:https://bitbucket.org/xgiovio/ios-ipa-resign/src 终于是可以了。 相关链接： https://github.com/maciekish/iReSign http://www.lai18.com/content/755251.html http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/ http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa https://www.google.com.hk/?gws_rd=ssl","content":"<p><a>一个自动重签ipa的需求。</a></p>\n<p>1.<a href=\"https://github.com/maciekish/iReSign\" target=\"_blank\" rel=\"noopener\">https://github.com/maciekish/iReSign</a> 一开始找到了这个自动重签开源工具。可以实现半自动的重签功能。但是并不能满足需求。继续吧</p>\n<p>2.找啊找啊，找。。发现所有的工具的源码都是归到了这几步命令。</p>\n<pre><code>Step1 : \nunzip YourApp.ipa\nStep2: \nrm -rf Payload/YourApp.app/_CodeSignature\nStep3: \ncp InHouse.mobileprovision Payload/YourApp.app/embedded.mobileprovision\nStep4: \n/usr/bin/codesign -f -s &quot;iPhone Distribution: YourCompanyName&quot; --resource-rules Payload/YourApp.app/ResourceRules.plist Payload/YourApp.app\nStep 5: \nzip -r YourApp_inhouse.ipa Payload\n* InHouse.mobileprovision 是你要用来签名的provision文件\n* iPhone Distribution: YourCompanyName 是指该签名对应的证书的名字。这个可以在keychain中找到\n</code></pre><p>   <a>但是会遇ResourceRules.plist找不到的问题，要设置</a></p>\n<pre><code>Click on your project &gt; Targets &gt; Select your target &gt; Build Settings &gt;\nCode Signing Resource Rules Path\nand add :\n$(SDKROOT)/ResourceRules.plist\n</code></pre><p><a>但是ipa中包含Framework and Plugins 也不能重签成功。</a><br><a id=\"more\"></a><br>3.<a href=\"https://github.com/ikalnitsky/iresign\" target=\"_blank\" rel=\"noopener\">https://github.com/ikalnitsky/iresign</a> 一个Python 重签脚本 一样的不能重签包含Framework and Plugins 的ipa</p>\n<p>4.就在放弃要打算重新看回iReSign源码做外部调用iReSign程序来坐自动重签时，又Google到一个脚本</p>\n<p><a href=\"http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/\" target=\"_blank\" rel=\"noopener\">http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/</a></p>\n<p>在signall.sh里边修改</p>\n<pre><code>signscript=&quot;/path/to/sign.sh&quot;                      #signscript脚本路径\n\nipasourcefolder=&quot;path/to/ipas/source/folder&quot;       #ipa文件的路径\n\nipadestfolder=&quot;/path/to/ipas/destinations/folder/&quot; #生成重签ipa路径\n\ndeveloper1=&quot;iPhone Developer: xxxxx (xxxxx)&quot;       #是指该签名对应的证书的名字。这个可以在keychain中找到\n\nmobileprovision1=&quot;/path/to/mobile/provision&quot;       #要重签的xx.mobileprovision文件路径\n\ncd $ipasourcefolder\n\nfind -d . -type f -name &quot;*.ipa&quot;&gt; files.txt\n\nwhile IFS=&apos;&apos; read -r line || [[ -n &quot;$line&quot; ]]; do\n\nfilename=$(basename &quot;$line&quot; .ipa)\necho &quot;Ipa: $filename&quot;\n#_dev1_______\noutput=$ipadestfolder$filename\noutput+=&quot;_signed_dev1.ipa&quot;                     #生成重签ipa的后缀名称\n&quot;$signscript&quot; &quot;$line&quot; &quot;$developer1&quot; &quot;$mobileprovision1&quot; &quot;$output&quot;\n\ndone &lt; files.txt\nrm files.txt\n</code></pre><p>源码:<a href=\"https://bitbucket.org/xgiovio/ios-ipa-resign/src\" target=\"_blank\" rel=\"noopener\">https://bitbucket.org/xgiovio/ios-ipa-resign/src</a></p>\n<p>终于是可以了。</p>\n<p>相关链接：</p>\n<p><a href=\"https://github.com/maciekish/iReSign\" target=\"_blank\" rel=\"noopener\">https://github.com/maciekish/iReSign</a></p>\n<p><a href=\"http://www.lai18.com/content/755251.html\" target=\"_blank\" rel=\"noopener\">http://www.lai18.com/content/755251.html</a></p>\n<p><a href=\"http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa</a></p>\n<p><a href=\"http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/\" target=\"_blank\" rel=\"noopener\">http://www.xgiovio.com/blog-photos-videos-other/blog/resign-your-ios-ipa-frameworks-and-plugins-included/</a></p>\n<p><a href=\"http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/26497863/xcode-6-1-error-while-building-ipa</a></p>\n<p><a href=\"https://www.google.com.hk/?gws_rd=ssl\" target=\"_blank\" rel=\"noopener\">https://www.google.com.hk/?gws_rd=ssl</a></p>\n","slug":"IPA-Resign","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-07-14-IPA-Resign.html","excerpt":"一个自动重签ipa的需求。 1.https://github.com/maciekish/iReSign 一开始找到了这个自动重签开源工具。可以实现半自动的重签功能。但是并不能满足需求。继续吧 2.找啊找啊，找。。发现所有的工具的源码都是归到了这几步命令。 Step1 : unzip YourApp.ipa Step2: rm -rf Payload/YourApp.app/_CodeSignature Step3: cp InHouse.mobileprovision Payload/YourApp.app/embedded.mobileprovision Step4: /usr/bin/codesign -f -s &quot;iPhone Distribution: YourCompanyName&quot; --resource-rules Payload/YourApp.app/ResourceRules.plist Payload/YourApp.app Step 5: zip -r YourApp_inhouse.ipa Payload * InHouse.mobileprovision 是你要用来签名的provision文件 * iPhone Distribution: YourCompanyName 是指该签名对应的证书的名字。这个可以在keychain中找到 但是会遇ResourceRules.plist找不到的问题，要设置 Click on your project &gt; Targets &gt; Select your target &gt; Build Settings &gt; Code Signing Resource Rules Path and add : $(SDKROOT)/ResourceRules.plist 但是ipa中包含Framework and Plugins 也不能重签成功。","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"关于block","date":"2016-06-18T05:16:22.000Z","path":"posts/default/2016-06-18-关于block.html","text":"__weak __typeof(self)weakSelf = self; self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^{ __strong __typeof(weakSelf)strongSelf = weakSelf; }]; weakSelf是为了block不持有self，避免循环引用（ block 持有了 self，block 持有了block。block 在self释放时候会释放，如果block持有了self，这时候self就释放不了），而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。 1.__weak 1&gt;.若附有__weak 修饰符的变量所引用的对象被废弃，则将nil 赋值给该变量。 2&gt;.使用附有__weak 修饰符的变量，即是使用注册到autoreleasepool 中的对象。 2.因为weakSelf 注册到autoreleasepool里边，可能会被释放所以在block里边要用把weakself修饰成强引用strongself来避免释放。 3.但是修饰成强引用strongself，会不会和self一样了呢？要是一样的话weakself是不是没有作用了，还是会出现循环引用问题. 1&gt;.答案是不会的。因为：block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题。 就是说block会引用self这个外部的变量，但是strongSelf这个内部变量是不会引用的。","content":"<pre><code>__weak __typeof(self)weakSelf = self;\nself.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^{\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n}];\n</code></pre><a id=\"more\"></a>\n<p>weakSelf是为了block不持有self，避免循环引用<a name=\"fenced-code-block\">（ block 持有了 self，block 持有了block。block 在self释放时候会释放，如果block持有了self，这时候self就释放不了）</a>，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。</p>\n<p><a>1.__weak</a></p>\n<pre><code>1&gt;.若附有__weak 修饰符的变量所引用的对象被废弃，则将nil 赋值给该变量。\n\n2&gt;.使用附有__weak 修饰符的变量，即是使用注册到autoreleasepool 中的对象。\n</code></pre><p><a>2.因为weakSelf 注册到autoreleasepool里边，可能会被释放所以在block里边要用把weakself修饰成强引用strongself来避免释放。</a></p>\n<p><a>3.但是修饰成强引用strongself，会不会和self一样了呢？要是一样的话weakself是不是没有作用了，还是会出现循环引用问题.</a></p>\n<pre><code>1&gt;.答案是不会的。因为：block 只有截获外部变量时，才会引用它。如果是内部新建一个，则没有任何问题。\n 就是说block会引用self这个外部的变量，但是strongSelf这个内部变量是不会引用的。\n</code></pre>","slug":"关于block","updated":"2017-11-17T02:23:17.234Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-06-18-关于block.html","excerpt":"__weak __typeof(self)weakSelf = self; self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^{ __strong __typeof(weakSelf)strongSelf = weakSelf; }];","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"JS与OC交互","date":"2016-06-15T06:34:01.000Z","path":"posts/default/2016-06-15-JS与OC交互.html","text":"参考链接：http://blog.csdn.net/lwjok2007/article/details/47058795 添加 JavaScriptCore.framework #import &lt;JavaScriptCore/JavaScriptCore.h&gt; js调用iOS分两种情况 一，js里面直接调用方法 -(void)webViewDidFinishLoad:(UIWebView *)webView { //网页加载完成调用此方法 //iOS调用js //首先创建JSContext 对象（此处通过当前webView的键获取到jscontext） JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //js调用iOS //第一种情况 //其中test1就是js的方法名称，赋给是一个block 里面是iOS代码 //此方法最终将打印出所有接收到的参数，js参数是不固定的 我们测试一下就知道 context[@&quot;test1&quot;] = ^() { NSArray *args = [JSContext currentArguments]; for (id obj in args) { NSLog(@&quot;%@&quot;,obj); } }; //此处我们没有写后台（但是前面我们已经知道iOS是可以调用js的，我们模拟一下） //首先准备一下js代码，来调用js的函数test1 然后执行 //一个参数 NSString *jsFunctStr=@&quot;test1(&apos;参数1&apos;)&quot;; [context evaluateScript:jsFunctStr]; //二个参数 NSString *jsFunctStr1=@&quot;test1(&apos;参数a&apos;,&apos;参数b&apos;)&quot;; [context evaluateScript:jsFunctStr1]; } 二，js里面通过对象调用方法 1.首先创建一个类 继承NSObject 并且规定一个协议 #import &lt;Foundation/Foundation.h&gt; #import &lt;JavaScriptCore/JavaScriptCore.h&gt; //首先创建一个实现了JSExport协议的协议 @protocol TestJSObjectProtocol &lt;JSExport&gt; //此处我们测试几种参数的情况 -(void)TestNOParameter; -(void)TestOneParameter:(NSString *)message; -(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2; @end //让我们创建的类实现上边的协议 @interface TestJSObject : NSObject&lt;TestJSObjectProtocol&gt; @end 2.类的实现 #import &quot;TestJSObject.h&quot; @implementation TestJSObject //一下方法都是只是打了个log 等会看log 以及参数能对上就说明js调用了此处的iOS 原生方法 -(void)TestNOParameter { NSLog(@&quot;this is ios TestNOParameter&quot;); } -(void)TestOneParameter:(NSString *)message { NSLog(@&quot;this is ios TestOneParameter=%@&quot;,message); } -(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2 { NSLog(@&quot;this is ios TestTowParameter=%@ Second=%@&quot;,message1,message2); } @end 3.调用代码如下： -(void)webViewDidFinishLoad:(UIWebView *)webView { //网页加载完成调用此方法 //首先创建JSContext 对象（此处通过当前webView的键获取到jscontext） JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; //第二种情况，js是通过对象调用的，我们假设js里面有一个对象 testobject 在调用方法 //首先创建我们新建类的对象，将他赋值给js的对象 TestJSObject *testJO=[TestJSObject new]; context[@&quot;testobject&quot;]=testJO; //同样我们也用刚才的方式模拟一下js调用方法 NSString *jsStr1=@&quot;testobject.TestNOParameter()&quot;; [context evaluateScript:jsStr1]; NSString *jsStr2=@&quot;testobject.TestOneParameter(&apos;参数1&apos;)&quot;; [context evaluateScript:jsStr2]; NSString *jsStr3=@&quot;testobject.TestTowParameterSecondParameter(&apos;参数A&apos;,&apos;参数B&apos;)&quot;; [context evaluateScript:jsStr3]; } 注意： 1.如果JS是一个参数 JS： testobject.TestOneParameter(&#39;参数1&#39;) 代理方法： -(void)TestOneParameter:(NSString *)message; 2.如果js是多个参数的话 我们代理方法的所有变量前的名字连起来要和js的方法名字一样 JS： testobject.TestTowParameterSecondParameter(&#39;参数A&#39;,&#39;参数B&#39;) 代理方法： -(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2; 注意 JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];应该放在-(void)webViewDidFinishLoad:(UIWebView *)webView，因为JSContext只会捕获当前页面JS事件。","content":"<p>参考链接：<a href=\"http://blog.csdn.net/lwjok2007/article/details/47058795\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/lwjok2007/article/details/47058795 </a></p>\n<pre><code>添加\nJavaScriptCore.framework\n\n#import &lt;JavaScriptCore/JavaScriptCore.h&gt; \n</code></pre><p>js调用iOS分两种情况<br><a id=\"more\"></a></p>\n<p>一，js里面直接调用方法</p>\n<pre><code>-(void)webViewDidFinishLoad:(UIWebView *)webView\n{\n    //网页加载完成调用此方法\n\n    //iOS调用js\n\n    //首先创建JSContext 对象（此处通过当前webView的键获取到jscontext）\n    JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];\n\n    //js调用iOS\n    //第一种情况\n    //其中test1就是js的方法名称，赋给是一个block 里面是iOS代码\n    //此方法最终将打印出所有接收到的参数，js参数是不固定的 我们测试一下就知道\n    context[@&quot;test1&quot;] = ^() {\n        NSArray *args = [JSContext currentArguments];\n        for (id obj in args) {\n            NSLog(@&quot;%@&quot;,obj);\n        }\n    };\n    //此处我们没有写后台（但是前面我们已经知道iOS是可以调用js的，我们模拟一下）\n    //首先准备一下js代码，来调用js的函数test1 然后执行\n    //一个参数\n    NSString *jsFunctStr=@&quot;test1(&apos;参数1&apos;)&quot;;\n    [context evaluateScript:jsFunctStr];\n\n    //二个参数\n    NSString *jsFunctStr1=@&quot;test1(&apos;参数a&apos;,&apos;参数b&apos;)&quot;;\n    [context evaluateScript:jsFunctStr1];\n\n}\n</code></pre><p>二，js里面通过对象调用方法</p>\n<p>1.首先创建一个类 继承NSObject 并且规定一个协议</p>\n<pre><code>#import &lt;Foundation/Foundation.h&gt;\n#import &lt;JavaScriptCore/JavaScriptCore.h&gt;\n//首先创建一个实现了JSExport协议的协议\n@protocol TestJSObjectProtocol &lt;JSExport&gt;\n//此处我们测试几种参数的情况\n-(void)TestNOParameter;\n-(void)TestOneParameter:(NSString *)message;\n-(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2;\n@end\n//让我们创建的类实现上边的协议\n@interface TestJSObject : NSObject&lt;TestJSObjectProtocol&gt;\n@end\n</code></pre><p>2.类的实现</p>\n<pre><code>#import &quot;TestJSObject.h&quot;  \n\n@implementation TestJSObject  \n\n//一下方法都是只是打了个log 等会看log 以及参数能对上就说明js调用了此处的iOS 原生方法  \n-(void)TestNOParameter  \n{  \n    NSLog(@&quot;this is ios TestNOParameter&quot;);  \n}  \n-(void)TestOneParameter:(NSString *)message  \n{  \n    NSLog(@&quot;this is ios TestOneParameter=%@&quot;,message);  \n}  \n-(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2  \n{  \n   NSLog(@&quot;this is ios TestTowParameter=%@  Second=%@&quot;,message1,message2);  \n}  \n@end  \n</code></pre><p>3.调用代码如下：</p>\n<pre><code>-(void)webViewDidFinishLoad:(UIWebView *)webView\n{\n    //网页加载完成调用此方法\n\n    //首先创建JSContext 对象（此处通过当前webView的键获取到jscontext）\n    JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];\n\n    //第二种情况，js是通过对象调用的，我们假设js里面有一个对象 testobject 在调用方法\n    //首先创建我们新建类的对象，将他赋值给js的对象\n\n    TestJSObject *testJO=[TestJSObject new];\n    context[@&quot;testobject&quot;]=testJO;\n\n    //同样我们也用刚才的方式模拟一下js调用方法\n    NSString *jsStr1=@&quot;testobject.TestNOParameter()&quot;;\n    [context evaluateScript:jsStr1];\n    NSString *jsStr2=@&quot;testobject.TestOneParameter(&apos;参数1&apos;)&quot;;\n    [context evaluateScript:jsStr2];\n    NSString *jsStr3=@&quot;testobject.TestTowParameterSecondParameter(&apos;参数A&apos;,&apos;参数B&apos;)&quot;;\n    [context evaluateScript:jsStr3];\n\n}\n</code></pre><p>注意：</p>\n<p>1.如果JS是一个参数</p>\n<p>JS：</p>\n<p><code>testobject.TestOneParameter(&#39;参数1&#39;)</code></p>\n<p>代理方法：</p>\n<p><code>-(void)TestOneParameter:(NSString *)message;</code></p>\n<p>2.如果js是多个参数的话  我们代理方法的所有变量前的名字连起来要和js的方法名字一样</p>\n<p>JS：</p>\n<p><code>testobject.TestTowParameterSecondParameter(&#39;参数A&#39;,&#39;参数B&#39;)</code></p>\n<p>代理方法：</p>\n<p><code>-(void)TestTowParameter:(NSString *)message1 SecondParameter:(NSString *)message2;</code></p>\n<p><a>注意</a></p>\n<p><code>JSContext *context=[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</code><br>应该放在<br><code>-(void)webViewDidFinishLoad:(UIWebView *)webView</code><br>，因为JSContext只会捕获当前页面JS事件。</p>\n","slug":"JS与OC交互","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-06-15-JS与OC交互.html","excerpt":"参考链接：http://blog.csdn.net/lwjok2007/article/details/47058795 添加 JavaScriptCore.framework #import &lt;JavaScriptCore/JavaScriptCore.h&gt; js调用iOS分两种情况","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"一个问题","date":"2016-06-06T02:39:13.000Z","path":"posts/default/2016-06-06-一个问题.html","text":"今天帮别人看了一个问题。 具体情况是：初始化两个数组添加了同一组数据（Model），然后数组A传 递到一个viewA里边，数组B传递到一个viewB里边。这时候ViewA中数组A 里边的model更新了值。发现ViewB中得数组B中得model也更新了。 指针问题。。 开始以为是数组指针问题，后来对数组处理也不行。才发现两个数组里边的 model 内存地址是一样的。。 自己的问题，记一下。","content":"<p><a name=\"fenced-code-block\">今天帮别人看了一个问题。</a></p>\n<pre><code>具体情况是：初始化两个数组添加了同一组数据（Model），然后数组A传\n递到一个viewA里边，数组B传递到一个viewB里边。这时候ViewA中数组A\n里边的model更新了值。发现ViewB中得数组B中得model也更新了。\n\n指针问题。。\n开始以为是数组指针问题，后来对数组处理也不行。才发现两个数组里边的\nmodel 内存地址是一样的。。 \n自己的问题，记一下。\n</code></pre>","slug":"一个问题","updated":"2017-11-17T02:23:17.234Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-06-06-一个问题.html","excerpt":"","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"CocoaPods","date":"2016-06-06T02:17:57.000Z","path":"posts/default/2016-06-06-CocoaPods.html","text":"cocoapods 安装 1&gt;.删除官方的ruby环境 gem sources --remove https://rubygems.org/ 2&gt;.等有反应之后再敲入以下命令 gem sources -a http://ruby.taobao.org/ 3&gt;.为了验证你的Ruby镜像是并且仅是taobao gem sources -l 显示为ruby.taboo.org为正确 *** CURRENT SOURCES *** http://ruby.taobao.org/ 4&gt;.安装cocoapods环境 sudo gem install -n /usr/local/bin cocoapods 5&gt;.设置pod pod setup 注意：使用CocoaPods时遇到pod setup失败 关于pod setup的详细解释在这里。对于初次使用CocoaPods的同 学，即使你不使用pod setup命令，在你初次执行pod install命 令时，系统也会自动执行pod setup。而由于长城的原因，不挂VPN 是不可能成功执行pod setup的。或许是我的VPN太垃圾，我挂上 VPN也依然没有执行成功。 解决办法: github上下载到了所需的文件。而只要将文件夹名改为master，将 其拖到/Users/用户名/.cocoapods/repos目录下即可。 注意：现在pod 被墙了pod update ==&gt; pod update –no-repo-updatepod install ==&gt; pod install –no-repo-update 更新报错：1.Unable to find a specification for xxxxx 只需要把当前Pod的目录清理一下就行了。在终端执行以下命令： 1. pod repo remove master 2. pod setup setup成功后执行install或update即可。 [!] Unable to satisfy the following requirements: - `Masonry (~&gt; 1.0.0)` required by `Podfile` - `Masonry (= 1.0.0)` required by `Podfile.lock` Podfile 里边更新到正确的版本号。","content":"<p><a name=\"fenced-code-block\">cocoapods 安装</a></p>\n<p>1&gt;.删除官方的ruby环境</p>\n<pre><code>gem sources --remove https://rubygems.org/\n</code></pre><p>2&gt;.等有反应之后再敲入以下命令</p>\n<pre><code>gem sources -a http://ruby.taobao.org/\n</code></pre><a id=\"more\"></a>\n<p>3&gt;.为了验证你的Ruby镜像是并且仅是taobao</p>\n<pre><code>  gem sources -l\n\n显示为ruby.taboo.org为正确\n*** CURRENT SOURCES ***    \nhttp://ruby.taobao.org/\n</code></pre><p>4&gt;.安装cocoapods环境</p>\n<pre><code>sudo gem install -n /usr/local/bin cocoapods\n</code></pre><p>5&gt;.设置pod</p>\n<pre><code>pod setup\n</code></pre><p>注意：使用CocoaPods时遇到pod setup失败<br>    关于pod setup的详细解释在这里。对于初次使用CocoaPods的同<br>    学，即使你不使用pod setup命令，在你初次执行pod install命<br>    令时，系统也会自动执行pod setup。而由于长城的原因，不挂VPN<br>    是不可能成功执行pod setup的。或许是我的VPN太垃圾，我挂上<br>    VPN也依然没有执行成功。</p>\n<p><a name=\"fenced-code-block\">解决办法: </a></p>\n<p><a name=\"fenced-code-block\">github上下载到了所需的文件。而只要将文件夹名改为master，将 其拖到/Users/用户名/.cocoapods/repos目录下即可。</a></p>\n<p>注意：现在pod 被墙了<br>pod update ==&gt; pod update –no-repo-update<br>pod install  ==&gt; pod install –no-repo-update</p>\n<p>更新报错：<br><a name=\"fenced-code-block\">1.Unable to find a specification for <code>xxxxx</code></a></p>\n<pre><code>只需要把当前Pod的目录清理一下就行了。在终端执行以下命令：\n1. pod repo remove master  \n2. pod setup  \nsetup成功后执行install或update即可。\n</code></pre><p><a name=\"fenced-code-block\">[!] Unable to satisfy the following requirements:</a></p>\n<pre><code>- `Masonry (~&gt; 1.0.0)` required by `Podfile`\n- `Masonry (= 1.0.0)` required by `Podfile.lock`\n</code></pre><p><a name=\"fenced-code-block\">Podfile 里边更新到正确的版本号。</a> </p>\n","slug":"CocoaPods","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-06-06-CocoaPods.html","excerpt":"cocoapods 安装 1&gt;.删除官方的ruby环境 gem sources --remove https://rubygems.org/ 2&gt;.等有反应之后再敲入以下命令 gem sources -a http://ruby.taobao.org/","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"iOS面试题汇总","date":"2016-05-31T09:58:22.000Z","path":"posts/default/2016-05-31-iOS面试题汇总.html","text":"群里边看到了有人分享了这篇面试题，拿来主义。。。 #阿里一面 1.Android的activity 2.Category支持添加属性与成员变量吗 3.是否了解设计模式, 用过哪些 4.iOS7之后, 蓝牙的围栏功能 5.MVC是否了解?介绍下使用情况。 6.MVC里面, View怎么通知到Model 7.了解delegate吗?并介绍 8.说说Cell重用原理 9.异步下载如何实现 10.做过最大的项目是什么?主要难点在哪里 11.如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么 12.学过哪些语言 13.C++里面虚函数作用 14.对o2o有什么看法(他是o2o部门的) 15.有没有什么想问的 #阿里二面 1.什么时候接触iOS 2.你的这些项目是外包还是自己开发的 3.OC允许多继承吗 4.要用什么方式实现多继承 5.了解内存管理吗, 吧唧吧唧… 6.了解设计模式吗 7.具体说说MVC 8.了解KVO吗 9.如果让你设计KVO, 要怎么设计 10.现在你是如何适配的 11.比较下storyboard和全代码 12.印象比较深的项目, 难点在哪 13.Cell重用机制具体怎么实现 14.如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动 15.平时是怎么进行测试的, 内存方面怎么测试 16.平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析.. 17.平时自己有没有封装过比较复杂的控件 18.在什么情况使用Notification 19.如何实现类似 “Find My iPhone” 这样功能 #网易1.自我介绍 2.学习iOS动机 3.对iOS的看法 4.谈项目 5.怎么看待审核被拒 6.怎么完成后期检测, 优化 7.id ,NSObject, id区别 8.了解iOS内存管理吗 9.release 和 autorelease 区别 10.autorelease 和 @autorelease区别 11.weak什么时候用 12.unsafe_unretained , weak, assign 区别 13.__block什么时候用 14.在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗 15.在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok 16.了解循环引用吗 17.NSThread, NSOperation, GCD区别 18.如何在异步下载时候, 取消下载, 保证流量不浪费 19.了解runtime吗 20.runtime什么时候用 21.通知和KVO区别 22.有序和无序set实现原理区别 23.深度遍历和广度遍历使用场景 24.算法题 * 2 25.常用的设计模式 26.哪些设计模式属于观察者模式 27.总结下刚才面试中哪些不足 28.自己有什么优点 29.有什么想问的 #网易二面 1.如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3] 2.实现连连看算法 3.T9算法如何实现, 全拼算法 #腾讯 自我介绍 如何保证软件质量, 怎么分析Crash日志 Xcode集成的测试工具了解哪些 如何获取应用数据 是否接触过友盟 是否了解Android 你的个人主页是怎么写的 谈谈你觉得最重要的一个项目 谈谈你的xxx项目 你这个项目里面集成了微信SDK, 谈谈使用感想 假如我是一名初学者, 你会向我推荐哪些第三方库 使用了第三方库, 有看他们是怎么实现的吗 有没有看过大型项目的源码 强连通量算法 最短路径算法 排序算法 25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名 #腾讯二面 在线敲代码 1.求两个整数的最大公约数 2.微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。 ##建议: 基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。 全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。 设计模式。 主流的那些设计模式非常有必要了解。 算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐&lt;剑指offer&gt;这本书。同时, 可以在这里线上答题: 牛客网-剑指offer 简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚 提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。 开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。 沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。 自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。 ##下边是我之前的总结的1.内存问题 1.arc的内存问题 block内存问题 — 什么时候用weak 1&gt;.循环引用都是strong会引起内存问题—&gt;strong变weak，assgin 2&gt;.出现无线循环时候，—&gt;合适时候手动关闭循环 3&gt;.arc 和mrc 混编时候 arc类在mrc使用要按照mrc规则 mrc类在arc使用要按照arc规则 4&gt;.arc 只是帮助管理retain，release 5&gt;.arc 把对象置nil后，对象没有指针指向，对象就会马上释放，用于释放对象 6&gt;.arc Strong 对应retain 修饰强引用 weak 对应assgin 对象释放后自动置nil 对象初始化默认修饰用__strong 对象指针默认修饰__autoreleaseing 7&gt;.__autoreleasing 一般用于方法返回值时候默认添加的很少显示的添加 8&gt;.不能使用NSAutoreleasePool 使用@autoreleasePool 9&gt;.arc 中block内存问题，如果block中引用了某个对象会对该对象引用计数加1，所以如果block引用了某个对象要用__block或者__weak来修饰。 10.&gt;CF*对象转换NS*对象时候要用__bridage 修饰符来桥接 2.多线程 NSThread GCD 1&gt;.NSThread 比较轻量级 但是要自己管理生命周期线程同步，线程加锁lock\\unlock | NSCondition lock\\unlock 也可以 @synchronized(obj) {} 互斥锁，obj 是要锁住的对象，｛｝是要锁的代码 锁定一份代码只用一个互斥锁，多个是无效的 缺点是消耗大量CPU资源 2&gt;. NSOperationQueue 工作原理：底层GCD实现，初始化子类，添加到operationQueue中 重写main方法自己执行线程 可以设置并发线程数量 可以用 [queue cacelAllOperations];停止线程 suspend 暂停|resume重新开始 3&gt;.GCD dispatch queue（官方推荐使用） 工作原理：底层还是线程实现，让程序平行排队任务，根据可用处理资源，安排他们在任何可用处理器核心上执行任务。任务可以是一个函数，也可以是一个block。 dispatch_async 执行完通知主线程 可以设置线程优先级 dispatch_group_async 可以监听一组线程 全部完成后通知主线程 dispatch_barrier_async 前边的任务完成才会执行，而他后边的任务要等他完成才会执 行。 dispatch_apply 执行某代码片段N次 3.weak 怎样置nil的 （weak 还是有一定性能消耗的） 建议是只在避免循环引用的时候使用__weak，一般在代理和block中使用 当weak修饰的对象被释放时候，指针会被赋值为nil，然后调用objc_release,因为引用计数为0 调用dealloc方法。 4.image 的imageName和imageWithContentsOfFile区别 imageName:使用时候系统会cache 程序员是无法处理cache的，所以多次使用该资源时候会提高性能，imageName会更好点 imageWithContentsOfFile:使用时候后会马上释放 如果该资源只是用一两次可以使用这种方式 5.image drawrect 的坐标切换 [image drawInRect:frame]; 6.设计模式 1&gt;.代理模式： 优势 解耦合。Delegate 2&gt;.观察者模式: 优势 解耦合。KVO，NSNotification 3&gt;.mvc模式： 通过设计模型，控制器逻辑，视图展示将程序进行逻辑划分。 优势 使系统层次清晰，逻辑分明 4&gt;.单例模式：Singleton 确保程序运行期间只有一份实例。 优势 使用简单，延时求值，易于跨模块。 5&gt;. 工厂模式：工厂类中自定了多个实例化对象接口，运行时候决定实例化哪个对象。 工厂类包含了逻辑判断，可以根据条件动态生成实例化类。减少耦合。 7.nonatomic 非原子性 atomic 原子性：给线程加锁。为了防止一个对象被多个线程同时使用，给线程加锁。因为atomic消耗比较大而iOS中很少有多个线程使用一个对象所以一般使用nonatomic 8.线程安全 1&gt;.@synchronized(obj) {} 互斥锁 obj 是要锁住的对象，｛｝是要锁的代码 锁定一份代码只用一个互斥锁，多个是无效的 缺点是消耗大量CPU资源 2&gt;.使用原子性atomic修饰属性 ： 线程安全，但是消耗大量CPU资源 建议：所有属性使用nonatomic修饰， 3&gt;. 线程锁：lock/unlock 条件锁：NSCondition lock/unlock 4&gt;. GCD 线程安全： 串行队列执行线程，dispatch_once(只执行一次)，dispatch_barriers_async(自定义并发队列)。 5&gt;.NSOperationQueue 设置线程并发数量。 总结： 尽量减少多线程操作一块资源，尽量把加锁，抢占资源的操作交给服务器，减少客户端压力。 9.数据库 10、runtime 运行时机制 runtime 是一个C语言底层库。可以用来实现一些OC不好实现或者不能实现的操作。 1&gt;.程序运行过程中，动态的创建一个类 2&gt;.程序运行过程中，动态为某个类添加属性,方法，或者修改某个类方法 3&gt;.遍历一个类中的所有属性或者方法 4&gt;.相关函数：objc_msgSend:给一个类发送消息 class_copyMethodList:遍历一个类的所有方法 class_copyIvarList：遍历一个类的所有属性 11.Clang 12.arm架构 CPU指令集。 13.autorelease pool 原理：对象添加autorelease pool 时候该对象内存地址会添加到autoreleasePoolPage的栈中的然后add一个标记（哨兵对象），然后release时候会从栈顶释放对象直到找到这个标记（哨兵对象）。 嵌套autoreleasePool：Pop 时候释放到标记（哨兵对象）为止，所以嵌套autoreleasePool 互不影响。 使用：1&gt;.新建线程时候。 2&gt;.for 循环里边有大量的临时变量。 14.arc 内部原理 iOS5引入 1.前端编译器：自动为创建对象插入retain(objc_retain)/release (objc_release) 2.arc 优化器 负责移除多余的retain/release语句 15.UITableViewCell 优化 1&gt;.适当的复用cell 2&gt;.缓存cell高度 不要在heightforrow 里边计算cell 高度 3&gt;.避免设置cell子试图为透明，造成多次渲染 4&gt;.避免使用图形特效，图形特性越多渲染越慢 5&gt;.复杂的界面在drawrect里边利用GPU来绘制view 效率比add view 和xib 高 6&gt;.减少逻辑计算时间 17.KVO,Notification,Delegate 类之间通信区别 1&gt;.delegate 是一对一 通信，delegate 往往需要关注返回值 2&gt;.Notification 一对多通信 不需要关心接收者，比KVO要多一步发送通知，但是范围广，更灵活点 3&gt;.KVO 一对多通信 ，不需要关心接收者，但是局限于属性变化的 4&gt;.属性传值：不灵活 5&gt;.将类整个传过去：不灵活，容易解耦 6&gt;.init方法传值 18.本地数据库海量数据怎么提高查询效率，和存储效率 1&gt;.避免全表查询：进行分表，外链查询， 2&gt;. 在设计where order by 的列上建立索引(一种排序的数据结构，以快速查询，更新数据库数据)。 19.索引的缺点 1&gt;.增加了数据库的存储空间。 2&gt;.添加和修改数据的时候花费较多的时间(因为索引也要跟着改变)。 20.断点续传方案 1&gt;.下载前，判断已经下载好的字节长度。 2&gt;.下载时，根据之前下载好的字节长度，从后边字节开始继续下载。 ASIHttpRequest 方法 setAllowResumeForFileDownloads 21.冒泡排序 NSInteger count = sortArray.count; for (NSInteger i = 1; i &lt;= count; i ++) { for (NSInteger j = 0; j &lt; i; j ++) { if(j + 1 &lt; count) { if ([sortArray[j] integerValue] &gt; [sortArray[j + 1] integerValue] ) { [sortArray exchangeObjectAtIndex:j withObjectAtIndex:j + 1];}} }} 22.PUSH原理 PUSH证书不能是带*号的证书 1&gt;.后台服务器将要发送的消息和iPhone的设备号一起发送到APNS服务器 2&gt;.APNS在已注册的iPhone的设备列表中找到改设备号的iPhone，并发送消息到该iPhone 3&gt;.iPhone收到消息后传送到对应的应用，弹出push 23.socket 编程 1&gt;.TCP：传输层 连接需要三次握手，长连接，断开时需要四次握手 2&gt;.HTTP：应用层 每次都请求都需要服务器回应，处理完后断开连接，称作“一次连接”，“短连接” 3&gt;.TCP/UDP区别： TCP：面向连接，通信安全，传输数据可靠，速度慢，系统开销比较大。 UDP：面向非连接，传输不可靠，用于少量数据传输，速度快 4&gt;.socket：套接字 是TCP/IP协议软件族通信的软件抽象层，它是一组借口。 工作原理： 1&gt;. 服务端：socket 函数生成一个socket，bind函数将本机ip地址和端口绑定，然后调用listen函数对相应socket监听，当accept接收到一个连接请求时，将生成一个新的socket，服务器显示该请求ip地址，并发送新的socket到客户端“im，sever”，关闭socket。 2&gt;. 客户端：调用socket生成一个socket，bind函数将本地ip地址和端口绑定，然后请求连接服务器，通过新的socket发送消息“im client”，关闭socket。 3&gt;.连接时可以指定通信协议，scoket可以支持不同的通信协议（TCP/UDP）当TCP协议连接时 该socket连接就是TCP连接。 24.NSRunLoop： iOS消息机制处理模式。 作用：控制NSRunloop里边线程的执行和休眠。","content":"<pre><code>群里边看到了有人分享了这篇面试题，拿来主义。。。\n</code></pre><p>#阿里一面</p>\n<p>1.<a href=\"/posts/default/2017-11-17-Android的activity.html\">Android的activity</a></p>\n<p>2.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">Category支持添加属性与成员变量吗</a></p>\n<p>3.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">是否了解设计模式, 用过哪些</a></p>\n<p>4.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">iOS7之后, 蓝牙的围栏功能</a></p>\n<p>5.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">MVC是否了解?介绍下使用情况。</a></p>\n<p>6.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">MVC里面, View怎么通知到Model</a></p>\n<p>7.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">了解delegate吗?并介绍</a><br><a id=\"more\"></a></p>\n<p>8.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">说说Cell重用原理</a></p>\n<p>9.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">异步下载如何实现</a></p>\n<p>10.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">做过最大的项目是什么?主要难点在哪里</a></p>\n<p>11.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">如果现在要实现一个下载功能, 你要如何设计。说说每个类具体做什么</a></p>\n<p>12.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">学过哪些语言</a></p>\n<p>13.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">C++里面虚函数作用</a></p>\n<p>14.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">对o2o有什么看法(他是o2o部门的)</a></p>\n<p>15.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">有没有什么想问的</a></p>\n<p>#阿里二面</p>\n<p>1.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">什么时候接触iOS</a></p>\n<p>2.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">你的这些项目是外包还是自己开发的</a></p>\n<p>3.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">OC允许多继承吗</a></p>\n<p>4.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">要用什么方式实现多继承</a></p>\n<p>5.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">了解内存管理吗, 吧唧吧唧…</a></p>\n<p>6.<a href=\"http://\" target=\"_blank\" rel=\"noopener\">了解设计模式吗</a></p>\n<p>7.具体说说MVC</p>\n<p>8.了解KVO吗</p>\n<p>9.如果让你设计KVO, 要怎么设计</p>\n<p>10.现在你是如何适配的</p>\n<p>11.比较下storyboard和全代码</p>\n<p>12.印象比较深的项目, 难点在哪</p>\n<p>13.Cell重用机制具体怎么实现</p>\n<p>14.如果有1w张图片要在屏幕滚动显示(每张图片满屏), 至少要几个cell, 如何实现循环滚动</p>\n<p>15.平时是怎么进行测试的, 内存方面怎么测试</p>\n<p>16.平时如何实现网络请求, 一般返回的数据是什么格式, 如何解析..</p>\n<p>17.平时自己有没有封装过比较复杂的控件</p>\n<p>18.在什么情况使用Notification</p>\n<p>19.如何实现类似 “Find My iPhone” 这样功能</p>\n<p>#网易<br>1.自我介绍</p>\n<p>2.学习iOS动机</p>\n<p>3.对iOS的看法</p>\n<p>4.谈项目</p>\n<p>5.怎么看待审核被拒</p>\n<p>6.怎么完成后期检测, 优化</p>\n<p>7.id ,NSObject, id<nsobject>区别</nsobject></p>\n<p>8.了解iOS内存管理吗</p>\n<p>9.release 和 autorelease 区别</p>\n<p>10.autorelease 和 @autorelease区别</p>\n<p>11.weak什么时候用</p>\n<p>12.unsafe_unretained , weak, assign 区别</p>\n<p>13.__block什么时候用</p>\n<p>14.在block里面, 对数组执行添加操作, 这个数组需要声明成 __block吗</p>\n<p>15.在block里面, 对NSInteger进行修改, 这个NSInteger是否需要声明成__blcok</p>\n<p>16.了解循环引用吗</p>\n<p>17.NSThread, NSOperation, GCD区别</p>\n<p>18.如何在异步下载时候, 取消下载, 保证流量不浪费</p>\n<p>19.了解runtime吗</p>\n<p>20.runtime什么时候用</p>\n<p>21.通知和KVO区别</p>\n<p>22.有序和无序set实现原理区别</p>\n<p>23.深度遍历和广度遍历使用场景</p>\n<p>24.算法题 * 2</p>\n<p>25.常用的设计模式</p>\n<p>26.哪些设计模式属于观察者模式</p>\n<p>27.总结下刚才面试中哪些不足</p>\n<p>28.自己有什么优点</p>\n<p>29.有什么想问的</p>\n<p>#网易二面</p>\n<p>1.如何实现一个数组每个元素依次向右移动k位。(后头的往前面补) 比如: [1, 2, 3, 4, 5] 挪两位变成[4, 5, 1, 2, 3]</p>\n<p>2.实现连连看算法</p>\n<p>3.T9算法如何实现, 全拼算法</p>\n<p>#腾讯</p>\n<ol>\n<li>自我介绍</li>\n<li>如何保证软件质量, 怎么分析Crash日志</li>\n<li>Xcode集成的测试工具了解哪些</li>\n<li>如何获取应用数据</li>\n<li>是否接触过友盟</li>\n<li>是否了解Android</li>\n<li>你的个人主页是怎么写的</li>\n<li>谈谈你觉得最重要的一个项目</li>\n<li>谈谈你的xxx项目</li>\n<li>你这个项目里面集成了微信SDK, 谈谈使用感想</li>\n<li>假如我是一名初学者, 你会向我推荐哪些第三方库</li>\n<li>使用了第三方库, 有看他们是怎么实现的吗</li>\n<li>有没有看过大型项目的源码</li>\n<li>强连通量算法</li>\n<li>最短路径算法</li>\n<li>排序算法</li>\n<li>25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名</li>\n</ol>\n<p>#腾讯二面</p>\n<p><strong>在线敲代码</strong></p>\n<p>1.求两个整数的最大公约数</p>\n<p>2.微信用户都是双向的好友，a是b的好友，那么b一定是a的。给定一个用户列表，有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，每组内的用 户，互相都不是好友。如果能，请给出这个划分。</p>\n<p>##建议: </p>\n<ol>\n<li>基础。 不管是哪个方向, 基础很重要。就比如iOS, objc的方方面面都必须了解。</li>\n<li>全面。 有些东西, 虽然不见得能答好, 但你至少应该懂。</li>\n<li>设计模式。 主流的那些设计模式非常有必要了解。</li>\n<li>算法。 这个不是说恶补能补好的。建议大家长期积累。 另外推荐&lt;剑指offer&gt;这本书。同时, 可以在这里线上答题: 牛客网-剑指offer</li>\n<li>简历一定要真实! 基本上面试官都是围绕简历展开交流的。 懂或不懂, 一问就知道, 没必要搬起石头砸自己的脚</li>\n<li>提前准备。 比如自我介绍, 项目介绍, 职业规划等等。基本都是必问的题目，能提前准备就提前准备好。</li>\n<li>开源, 分享, 积累。 我一直认为, 分享和开源是程序员进步的不二法门。 我建议每个程序员都应该有自己的Github, 有自己的博客。就这几次面试来说, 博客和Github帮了我多。 网易面试官直言, 他们认真看过我的Github, 微信HR问我要CSDN博客ID, 说她很感兴趣。帮助别人, 也是帮助自己。</li>\n<li>沟通。 有时候一个问题, 可能不懂, 甚至题目都不理解。不要害怕, 主动与面试官沟通。 我在网易面试的时候, 关于全拼算法的实现, 我当时连全拼都没一个完整的概念, 它要满足哪些条件更加不清楚。我跟面试官坦诚我不懂这个概念, 与他们的一步步沟通中实现了自己的算法。 所以沟通, 远比闷头写, 到头来还可能错误来的实在。</li>\n<li>自信。 能得到面试机会, 最起码证明, 你很优秀。 我觉得自信很重要。 如果一开始, 就表现的慌慌张张, 畏首畏尾, 那么不管是你自己的发挥, 还是面试官对你的看法, 我觉得都不会很好。</li>\n</ol>\n<p>##下边是我之前的总结的<br>1.内存问题</p>\n<pre><code>1.arc的内存问题 block内存问题 — 什么时候用weak\n1&gt;.循环引用都是strong会引起内存问题—&gt;strong变weak，assgin\n2&gt;.出现无线循环时候，—&gt;合适时候手动关闭循环\n3&gt;.arc 和mrc 混编时候 arc类在mrc使用要按照mrc规则  mrc类在arc使用要按照arc规则\n4&gt;.arc 只是帮助管理retain，release\n5&gt;.arc 把对象置nil后，对象没有指针指向，对象就会马上释放，用于释放对象\n6&gt;.arc Strong 对应retain 修饰强引用 weak 对应assgin 对象释放后自动置nil\n对象初始化默认修饰用__strong 对象指针默认修饰__autoreleaseing\n7&gt;.__autoreleasing 一般用于方法返回值时候默认添加的很少显示的添加\n8&gt;.不能使用NSAutoreleasePool 使用@autoreleasePool\n9&gt;.arc 中block内存问题，如果block中引用了某个对象会对该对象引用计数加1，所以如果block引用了某个对象要用__block或者__weak来修饰。\n10.&gt;CF*对象转换NS*对象时候要用__bridage 修饰符来桥接\n</code></pre><p>2.多线程 NSThread  GCD</p>\n<pre><code>1&gt;.NSThread\n比较轻量级 但是要自己管理生命周期线程同步，线程加锁lock\\unlock  | NSCondition lock\\unlock 也可以\n  @synchronized(obj) {} 互斥锁，obj 是要锁住的对象，｛｝是要锁的代码\n 锁定一份代码只用一个互斥锁，多个是无效的\n       缺点是消耗大量CPU资源\n2&gt;. NSOperationQueue\n工作原理：底层GCD实现，初始化子类，添加到operationQueue中 重写main方法自己执行线程\n         可以设置并发线程数量\n        可以用 [queue cacelAllOperations];停止线程 suspend 暂停|resume重新开始\n3&gt;.GCD dispatch queue（官方推荐使用）\n工作原理：底层还是线程实现，让程序平行排队任务，根据可用处理资源，安排他们在任何可用处理器核心上执行任务。任务可以是一个函数，也可以是一个block。\n    dispatch_async 执行完通知主线程 可以设置线程优先级\n    dispatch_group_async 可以监听一组线程 全部完成后通知主线程\n    dispatch_barrier_async 前边的任务完成才会执行，而他后边的任务要等他完成才会执       行。\n    dispatch_apply 执行某代码片段N次\n</code></pre><p>3.weak 怎样置nil的 （weak 还是有一定性能消耗的）</p>\n<pre><code>建议是只在避免循环引用的时候使用__weak，一般在代理和block中使用\n当weak修饰的对象被释放时候，指针会被赋值为nil，然后调用objc_release,因为引用计数为0 调用dealloc方法。\n</code></pre><p>4.image 的imageName和imageWithContentsOfFile区别</p>\n<pre><code>imageName:使用时候系统会cache 程序员是无法处理cache的，所以多次使用该资源时候会提高性能，imageName会更好点\nimageWithContentsOfFile:使用时候后会马上释放 如果该资源只是用一两次可以使用这种方式\n</code></pre><p>5.image drawrect 的坐标切换</p>\n<pre><code>[image drawInRect:frame];\n</code></pre><p>6.设计模式</p>\n<pre><code>1&gt;.代理模式：\n 优势 解耦合。Delegate\n2&gt;.观察者模式:\n 优势 解耦合。KVO，NSNotification\n3&gt;.mvc模式：\n 通过设计模型，控制器逻辑，视图展示将程序进行逻辑划分。\n 优势 使系统层次清晰，逻辑分明\n4&gt;.单例模式：Singleton\n 确保程序运行期间只有一份实例。\n 优势 使用简单，延时求值，易于跨模块。\n5&gt;. 工厂模式：工厂类中自定了多个实例化对象接口，运行时候决定实例化哪个对象。\n工厂类包含了逻辑判断，可以根据条件动态生成实例化类。减少耦合。\n</code></pre><p>7.nonatomic 非原子性</p>\n<pre><code>atomic 原子性：给线程加锁。为了防止一个对象被多个线程同时使用，给线程加锁。因为atomic消耗比较大而iOS中很少有多个线程使用一个对象所以一般使用nonatomic\n</code></pre><p>8.线程安全</p>\n<pre><code>1&gt;.@synchronized(obj) {} 互斥锁\n obj 是要锁住的对象，｛｝是要锁的代码\n        锁定一份代码只用一个互斥锁，多个是无效的\n        缺点是消耗大量CPU资源\n2&gt;.使用原子性atomic修饰属性 ：\n   线程安全，但是消耗大量CPU资源\n建议：所有属性使用nonatomic修饰，\n3&gt;. 线程锁：lock/unlock 条件锁：NSCondition lock/unlock\n4&gt;. GCD 线程安全：\n串行队列执行线程，dispatch_once(只执行一次)，dispatch_barriers_async(自定义并发队列)。\n5&gt;.NSOperationQueue 设置线程并发数量。\n总结：\n尽量减少多线程操作一块资源，尽量把加锁，抢占资源的操作交给服务器，减少客户端压力。\n</code></pre><p>9.数据库</p>\n<p>10、runtime 运行时机制</p>\n<pre><code>runtime 是一个C语言底层库。可以用来实现一些OC不好实现或者不能实现的操作。\n1&gt;.程序运行过程中，动态的创建一个类\n2&gt;.程序运行过程中，动态为某个类添加属性,方法，或者修改某个类方法\n3&gt;.遍历一个类中的所有属性或者方法\n4&gt;.相关函数：objc_msgSend:给一个类发送消息\n  class_copyMethodList:遍历一个类的所有方法\n  class_copyIvarList：遍历一个类的所有属性\n</code></pre><p>11.Clang</p>\n<p>12.arm架构 CPU指令集。</p>\n<p>13.autorelease pool</p>\n<pre><code>原理：对象添加autorelease pool 时候该对象内存地址会添加到autoreleasePoolPage的栈中的然后add一个标记（哨兵对象），然后release时候会从栈顶释放对象直到找到这个标记（哨兵对象）。\n嵌套autoreleasePool：Pop 时候释放到标记（哨兵对象）为止，所以嵌套autoreleasePool 互不影响。\n使用：1&gt;.新建线程时候。\n      2&gt;.for 循环里边有大量的临时变量。\n</code></pre><p>14.arc 内部原理 iOS5引入</p>\n<pre><code>1.前端编译器：自动为创建对象插入retain(objc_retain)/release (objc_release)\n2.arc 优化器 负责移除多余的retain/release语句\n</code></pre><p>15.UITableViewCell 优化</p>\n<pre><code>1&gt;.适当的复用cell\n2&gt;.缓存cell高度 不要在heightforrow 里边计算cell 高度\n3&gt;.避免设置cell子试图为透明，造成多次渲染\n4&gt;.避免使用图形特效，图形特性越多渲染越慢\n5&gt;.复杂的界面在drawrect里边利用GPU来绘制view 效率比add view 和xib 高\n6&gt;.减少逻辑计算时间\n</code></pre><p>17.KVO,Notification,Delegate 类之间通信区别</p>\n<pre><code>1&gt;.delegate 是一对一 通信，delegate 往往需要关注返回值\n2&gt;.Notification 一对多通信 不需要关心接收者，比KVO要多一步发送通知，但是范围广，更灵活点\n3&gt;.KVO 一对多通信 ，不需要关心接收者，但是局限于属性变化的\n4&gt;.属性传值：不灵活\n5&gt;.将类整个传过去：不灵活，容易解耦\n6&gt;.init方法传值\n</code></pre><p>18.本地数据库海量数据怎么提高查询效率，和存储效率</p>\n<pre><code>1&gt;.避免全表查询：进行分表，外链查询，\n2&gt;. 在设计where order by 的列上建立索引(一种排序的数据结构，以快速查询，更新数据库数据)。\n</code></pre><p>19.索引的缺点</p>\n<pre><code>1&gt;.增加了数据库的存储空间。\n2&gt;.添加和修改数据的时候花费较多的时间(因为索引也要跟着改变)。\n</code></pre><p>20.断点续传方案</p>\n<pre><code>1&gt;.下载前，判断已经下载好的字节长度。\n2&gt;.下载时，根据之前下载好的字节长度，从后边字节开始继续下载。\nASIHttpRequest 方法 setAllowResumeForFileDownloads\n</code></pre><p>21.冒泡排序<br>   NSInteger count = sortArray.count;</p>\n<pre><code>for (NSInteger i = 1; i &lt;= count; i ++) {\n\n    for (NSInteger j = 0; j &lt; i; j ++) {\n\n        if(j + 1 &lt; count) {\n\n            if ([sortArray[j] integerValue] &gt; [sortArray[j + 1] integerValue] ) {\n\n                [sortArray exchangeObjectAtIndex:j withObjectAtIndex:j + 1];}} }}\n</code></pre><p>22.PUSH原理 PUSH证书不能是带*号的证书</p>\n<pre><code>1&gt;.后台服务器将要发送的消息和iPhone的设备号一起发送到APNS服务器\n2&gt;.APNS在已注册的iPhone的设备列表中找到改设备号的iPhone，并发送消息到该iPhone\n3&gt;.iPhone收到消息后传送到对应的应用，弹出push\n</code></pre><p>23.socket 编程</p>\n<pre><code>1&gt;.TCP：传输层 连接需要三次握手，长连接，断开时需要四次握手\n2&gt;.HTTP：应用层 每次都请求都需要服务器回应，处理完后断开连接，称作“一次连接”，“短连接”\n3&gt;.TCP/UDP区别：\nTCP：面向连接，通信安全，传输数据可靠，速度慢，系统开销比较大。\nUDP：面向非连接，传输不可靠，用于少量数据传输，速度快\n</code></pre><p>4&gt;.socket：套接字 是TCP/IP协议软件族通信的软件抽象层，它是一组借口。</p>\n<pre><code>工作原理：\n1&gt;. 服务端：socket 函数生成一个socket，bind函数将本机ip地址和端口绑定，然后调用listen函数对相应socket监听，当accept接收到一个连接请求时，将生成一个新的socket，服务器显示该请求ip地址，并发送新的socket到客户端“im，sever”，关闭socket。\n2&gt;. 客户端：调用socket生成一个socket，bind函数将本地ip地址和端口绑定，然后请求连接服务器，通过新的socket发送消息“im client”，关闭socket。\n3&gt;.连接时可以指定通信协议，scoket可以支持不同的通信协议（TCP/UDP）当TCP协议连接时 该socket连接就是TCP连接。\n</code></pre><p>24.NSRunLoop： iOS消息机制处理模式。</p>\n<pre><code>作用：控制NSRunloop里边线程的执行和休眠。\n</code></pre>","slug":"iOS面试题汇总","updated":"2017-11-19T14:51:11.040Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-05-31-iOS面试题汇总.html","excerpt":"群里边看到了有人分享了这篇面试题，拿来主义。。。 #阿里一面 1.Android的activity 2.Category支持添加属性与成员变量吗 3.是否了解设计模式, 用过哪些 4.iOS7之后, 蓝牙的围栏功能 5.MVC是否了解?介绍下使用情况。 6.MVC里面, View怎么通知到Model 7.了解delegate吗?并介绍","categories":[],"tags":[{"name":"iOS面试题","slug":"iOS面试题","permalink":"http://imjade.github.io/tags/iOS面试题/"}]},{"title":"Framework 开发的那些事","date":"2016-05-26T08:27:43.000Z","path":"posts/default/2016-05-26-Framework-开发的那些事.html","text":"1.static A 嵌套了static B1&gt;.因为static B中使用了一些动态库(dylib) 但是staticA中无法添加dylib文件 报错： error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: file: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/usr/lib/libz.tbd is not an object file (not allowed in a library) 2&gt;.如果不添加dylib就会 报错： ld: framework not found PywSdk for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) 但是staticB中用到了 系统.Framework 可以添加到staticA中 设想：如果staticB中没有用到dylib库应该是可以static嵌套static吧 2.dynamic A 嵌套 dynamic B/static B1&gt;.因为dynamic是系统保存一份的。所以dynamic A中不能使用和一样的文件和全局文件。报文件重复错误，所以dynamicA中文件和全局变量要避免和dynamic B/static B中得一样。要是一定要用一样的文件要修改文件加个前缀。 报错：","content":"<h3 id=\"1-static-A-嵌套了static-B\"><a href=\"#1-static-A-嵌套了static-B\" class=\"headerlink\" title=\"1.static A 嵌套了static B\"></a>1.static A 嵌套了static B</h3><pre><code>1&gt;.因为static B中使用了一些动态库(dylib) 但是staticA中无法添加dylib文件 \n报错：\nerror: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: \nfile: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/usr/lib/libz.tbd is not an object file (not allowed in a library)\n</code></pre><p><img src=\"http://o7rvtx931.bkt.clouddn.com/image17CE12794-3913-4CE4-86E3-B6B5470A4F36.png\" alt=\"报错信息\"><br>    <a id=\"more\"></a><br>    2&gt;.如果不添加dylib就会<br>    报错：<br>    ld: framework not found PywSdk for architecture x86_64<br>    clang: error: linker command failed with exit code 1 (use -v to see invocation)<br><img src=\"http://o7rvtx931.bkt.clouddn.com/7552CFF2-3577-4874-B18A-F9E1ECE57691.png\" alt=\"报错信息\"><br>    但是staticB中用到了 <a name=\"fenced-code-block\">系统.Framework</a> 可以添加到staticA中<br>    设想：如果staticB中没有用到dylib库应该是可以static嵌套static吧</p>\n<h3 id=\"2-dynamic-A-嵌套-dynamic-B-static-B\"><a href=\"#2-dynamic-A-嵌套-dynamic-B-static-B\" class=\"headerlink\" title=\"2.dynamic A 嵌套 dynamic B/static B\"></a>2.dynamic A 嵌套 dynamic B/static B</h3><pre><code>1&gt;.因为dynamic是系统保存一份的。所以dynamic A中不能使用和一样的文件和全局文件。报文件重复错误，所以dynamicA中文件和全局变量要避免和dynamic B/static B中得一样。要是一定要用一样的文件要修改文件加个前缀。\n报错：\n</code></pre><p><img src=\"http://o7rvtx931.bkt.clouddn.com/95441BC2-0D41-4552-8FA9-F0DB4447BB84.png\" alt=\"报错信息\"></p>\n","slug":"Framework-开发的那些事","updated":"2017-11-17T02:23:17.232Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-05-26-Framework-开发的那些事.html","excerpt":"1.static A 嵌套了static B1&gt;.因为static B中使用了一些动态库(dylib) 但是staticA中无法添加dylib文件 报错： error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: file: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/usr/lib/libz.tbd is not an object file (not allowed in a library)","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"磕磕碰碰2.1","date":"2016-05-26T05:46:56.000Z","path":"posts/default/2016-05-26-磕磕碰碰2-1.html","text":"前提：正在做SDK（Framework）给客户集成 就在前几天领导说要开发一个新版本，要实现一个功能：“给集成Framework_a的ipa文件替换成Framework_b，不需要重新打包ipa文件”。 经过了一些坑…Framework开发的那些事 最终完成了2.1的版本开发。 记录一下。","content":"<pre><code>前提：正在做SDK（Framework）给客户集成\n就在前几天领导说要开发一个新版本，要实现一个功能：“给集成Framework_a的ipa文件替换成Framework_b，不需要重新打包ipa文件”。\n</code></pre><a id=\"more\"></a>\n<p>经过了一些坑…<a href=\"http://imjade.github.io/posts/uncategorized/2016-05-26-Framework-%E5%BC%80%E5%8F%91%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.html\">Framework开发的那些事</a> 最终完成了2.1的版本开发。</p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/liucheng_pic.jpg\" alt=\"流程\"></p>\n<p><img src=\"http://o7rvtx931.bkt.clouddn.com/liucheng_text.jpg\" alt=\"流程\"></p>\n<p><code>记录一下。</code></p>\n","slug":"磕磕碰碰2-1","updated":"2017-11-17T02:23:17.235Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-05-26-磕磕碰碰2-1.html","excerpt":"前提：正在做SDK（Framework）给客户集成 就在前几天领导说要开发一个新版本，要实现一个功能：“给集成Framework_a的ipa文件替换成Framework_b，不需要重新打包ipa文件”。","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]},{"title":"ios Framework 合并","date":"2016-05-16T10:08:01.000Z","path":"posts/default/2016-05-16-hello.html","text":"1. 查看ios Framework 支持的Cpu 框架 xxx/.xxx.framework (xxx路径下) cd xxx/.xxx.framework lipo -info xxx 2. 合并framework a:xxx/abc.framwork b:sss/abc.framework lipo -create xxx/a.framwork/abc sss/abc.framework -output newabc 生成framework二进制文件在sss/abc.framework下","content":"<pre><code>1. 查看ios Framework 支持的Cpu 框架 xxx/.xxx.framework (xxx路径下)\n\n     cd xxx/.xxx.framework\n\n     lipo -info xxx\n\n2. 合并framework a:xxx/abc.framwork b:sss/abc.framework\n\n    lipo -create xxx/a.framwork/abc sss/abc.framework -output newabc \n\n    生成framework二进制文件在sss/abc.framework下\n</code></pre>","slug":"hello","updated":"2017-11-17T02:23:17.233Z","comments":true,"link":"","permalink":"http://imjade.github.io/posts/default/2016-05-16-hello.html","excerpt":"","categories":[],"tags":[{"name":"iOS 记录","slug":"iOS-记录","permalink":"http://imjade.github.io/tags/iOS-记录/"}]}]}